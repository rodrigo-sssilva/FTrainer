--[[
Freedom Planet trainer for speedrunners. I hope this is an useful tool
Fladervy

Special thanks to Dazl and Antylamon for finding the some of pointers I used here.
]]--
require("changeHotKeyKeys")
require("ftrainerpointers")


--Current game version being recognized/prioritized.
postWarpCode = 0
FPVersion = 0
FPTrainerTitle = "FTrainer 3.5 WIP"

RandomExplodeRate = 10000 --used on the random explode toggle

-- Lists of frames where the player is allowed to warp (where custom checkpoints are functional)
-- FirstFrames contains first screen numbers of the stages, and FollowFrames does the same for other screens.
-- This separation is important for certain attributions on custom warps.
arrayFirstFrames = {16,20,24,29,35,39,44,50,56,59,65,67,69,71}
arrayNextFrames = {17,18,19,21,22,23,25,26,27,28,30,31,32,33,34,36,37,38,40,41,42,43,45,46,47,48,49,51,52,53,54,55,57,58,60,61,62,63,64,66,68,70,84}

-- Minor functions for general use

--Returns true if string is empty.
local function isempty(s)
  return s == nil or s == ''
end

--Returns true if the table tab has value val. Returns false otherwise.
function has_value (tab, val)
    for index, value in ipairs (tab) do
        if value == val then
            return true
        end
    end

    return false
end

--TODO: make a single function Round with decimal digits as a parameter.

--Rounds a float point number to 3 decimal digits.
function Round3(num)
    return math.floor(1000*num+0.5)/1000
end

--Rounds a float point number to 5 decimal digits.
function Round1(num)
    return math.floor(10*num+0.5)/10
end

--Rounds a float point number to 4 decimal digits.
function Round4(num)
    return math.floor(10000*num + 0.5)/10000
end

-- For the extra button hotkeys (at the bottom)
setGlobalKeyPollInterval(100)
VK_OEM_MINUS = 189
VK_OEM_PLUS = 187
VK_OEM_1 = 192
VK_OEM_5 = 220
VK_OEM_7 = 222

--Segment automatically generated by CE

gPlaySoundOnAction=false
FTrainerMain.show()

-- This function runs when the trainer is closed.
function CloseClick()
    writeInteger(varLives,5)
--undoes all settings that use code injection
    if miscSuperdog then
        setProperty(FTrainerMain.CECheckbox10,"Checked",false)
        ToggleSuperdog()
    end
    if miscInstantDeath then
        setProperty(FTrainerMain.CECheckbox11,"Checked",false)
        ToggleInstantDeath()
    end
    if miscCameraLock then
        setProperty(FTrainerMain.CECheckbox13,"Checked",false)
        ToggleCameraLock()
    end
    if miscLimitedLives then
        setProperty(FTrainerMain.CECheckbox12,"Checked",false)
        ToggleLimitedLives()
    end
    if miscSpeedScreen then
        setProperty(FTrainerMain.CECheckbox14,"Checked",false)
        ShowSpeedOnScreen()
    end
    if miscHealthScreen then
        setProperty(FTrainerMain.CECheckbox17,"Checked",false)
        ShowHealthOnScreen()
    end
    if miscMovement then
        setProperty(FTrainerMain.CECheckbox16,"Checked",false)
        ToggleMiscMovement()
    end
    if miscInvincibility then
        setProperty(FTrainerMain.CECheckbox21,"Checked",false)
        ToggleInvincibility()
    end
    closeCE()
    return caFree
end

--Dataview functions and general boxes outside tabs


-- Toggles the dataview on and off, based on the refresh timer activation
function CEButton1Click()
    if ReattachFP(0) == 0 then return end
    if(FTrainerMain.CETimer1.getEnabled()==false) then
        --dataview is being turned on
        setProperty(FTrainerMain.CEButton1, "Caption", "Stop Dataview")
        FTrainerMain.CETimer1.setEnabled(true)
        CETimer1Timer()
        return
    end
    --dataview is being turned off
    setProperty(FTrainerMain.CEButton1, "Caption", "Start Dataview")
    FTrainerMain.CETimer1.setEnabled(false)
    setProperty(FTrainerMain.labelPosX,"Caption", "Horizontal Position")
    setProperty(FTrainerMain.labelPosY,"Caption", "Vertical Position")
    setProperty(FTrainerMain.labelSpeed,"Caption", "Ground Speed")
    setProperty(FTrainerMain.labelSpeedY,"Caption", "Vertical Speed")
    FTrainerMain.labelSpeed.Font.Color = 0x000000
    FTrainerMain.labelSpeedY.Font.Color = 0x000000
end

--Changes custom shield boxes behaviour
function BCustomShieldChange()
    UpdateCustomStatus()
end

--Sets new dataview refresh rate
function CETrackBar1Change()
    setProperty(FTrainerMain.CETimer1, "Interval", getProperty(FTrainerMain.CETrackBar1,"Position"))
    setProperty(FTrainerMain.CELabel1, "Caption", "Refresh Rate: " .. getProperty(FTrainerMain.CETrackBar1,"Position") .. " ms")
end

--Changes input lock on custom warp state
function CECheckbox2Change()
    if(checkbox_getState(FTrainerMain.CECheckbox2) == 0) then
      customLock = 1
    else
      customLock = 0
    end
    UpdateCustomStatus()
end

--Updates normal, advanced and object dataviews
function CETimer1Timer()
    if ReattachFP(0) == 0 then return end
        --checks if the object dataview should also be updated
    if getProperty(FTrainerObject.CECheckbox1,"Checked") then
        UpdateObjectDataview()
    end
    --checks if advanced dataview should be updated instead of basic dataview
    if getProperty(FTrainerDataview.CECheckbox1,"Checked") then
        --sets default values to texts.
        setProperty(FTrainerMain.labelPosX,"Caption", "Horizontal Position")
        setProperty(FTrainerMain.labelPosY,"Caption", "Vertical Position")
        setProperty(FTrainerMain.labelSpeed,"Caption", "Ground Speed")
        setProperty(FTrainerMain.labelSpeedY,"Caption", "Vertical Speed")
        FTrainerMain.labelSpeed.Font.Color = 0x000000
        FTrainerMain.labelSpeedY.Font.Color = 0x000000
        -- updates button text
        if getProperty(FTrainerDataview.CECheckbox1,"Checked") then
           UpdateAdvancedDataview()
           setProperty(FTrainerMain.CEButton1, "Caption", "Stop Dataview")
        else
            FTrainerMain.CETimer1.setEnabled(false)
            setProperty(FTrainerMain.CEButton1, "Caption", "Start Dataview")
        end
        return
    end

    -- updates basic dataview
    displayPosX = readDouble(varTrueX)
    displayPosY = readDouble(varTrueY)
    displaySpeed = readDouble(varSpeedX)
    displaySpeedY = readDouble(varSpeedY)
    if (isempty(displayPosX))
    then
        setProperty(FTrainerMain.labelPosX,"Caption", "Pos X: 0.0")
    else
        setProperty(FTrainerMain.labelPosX,"Caption", "Pos X: " .. Round1(displayPosX))
    end
    if (isempty(displayPosY)) then
        setProperty(FTrainerMain.labelPosY,"Caption", "Pos Y: 0.0")
    else
        setProperty(FTrainerMain.labelPosY,"Caption", "Pos Y: " .. Round1(displayPosY))
    end
    if (isempty(displaySpeed))
    then
        setProperty(FTrainerMain.labelSpeed,"Caption", "Speed: 0.0")
    else
        --Changes the text color to red if the player reaches the speed cap
        setProperty(FTrainerMain.labelSpeed,"Caption", "Speed: " .. Round1(displaySpeed))
        if (displaySpeed>=15 or displaySpeed<=-15) then
           FTrainerMain.labelSpeed.Font.Color = 0x0000ff
        else  FTrainerMain.labelSpeed.Font.Color = 0x000000 end
    end
    if (isempty(displaySpeedY) or displaySpeedY == 0)
    then
        setProperty(FTrainerMain.labelSpeedY,"Caption", "YSpeed: 0.0")
    else
        --Changes the text color to red if the player reaches the speed cap
        setProperty(FTrainerMain.labelSpeedY,"Caption", "YSpeed: " .. -1*Round1(displaySpeedY))
        if(displaySpeedY>=15 or displaySpeedY<=-15) then
            FTrainerMain.labelSpeedY.Font.Color = 0x0000ff
        -- Changes the text color to blue if the player is within air drag speed
        else if (displaySpeedY>-4 and displaySpeedY < 0) then
            FTrainerMain.labelSpeedY.Font.Color = 0xff0000
        else  FTrainerMain.labelSpeedY.Font.Color = 0x000000 end
     end end
end

--Functions Called by Hotkeys

--Function called before any warp attribution.
--Returns 0 if the warp function is not activated.
--the value 0 is used by hotkey functions to ignore warps.

--argument is 1 if the checkbox verification should be ignored. 0 otherwise.
function HotkeyWarpGeneral(a)
    --if ReattachFP(0) == 0 then return 0 end
    if not compareTopWindow() then return 0 end

    -- if the player is on a frame where everything is unitialized (just started the game),
    -- warp to the time attack screen first.
    if readInteger(varFrame) < 1 then
        writeInteger(varGotoFrame,3)
        --why -24? -20 from delaying 2 frames after warp
        --and -3 to undo the +3 later on to result in -1
        if inputBreakpointIsActive == -1 then inputBreakpointIsActive = -24
            --and -18 here to become +5
        else if inputBreakpointIsActive == -2 then inputBreakpointIsActive = -28
        else inputBreakpointIsActive = -20 end end
        return 0
    end

    -- reset player and timer attributes
    writeDouble(varCharacter, customCharacter)
    writeDouble(varShield, 0)
    writeDouble(varHealth, 14)
    -- sets the timer to 10 minutes minimum
    if getProperty(FTrainerMain.CECheckbox18,"Checked") then
        writeDouble(varIgt, 600000)
    else
        if readDouble(varIgt) < 600000 then
            writeDouble(varIgt,readDouble(varIgt)+600000)
        end
    end
    writeDouble(varMeter, 100)
    writeDouble(varCrystals, 400)
    writeDouble(varInvincibility,0)
    writeBytes(varPaused,{1})
    --sets up timer stop
    miscTimerStopTrigger = false
    miscTimerLimitTrigger = false
    return 1
end

--Default Warp Functions

--DV Boss Skip
function HotkeyWarp1()
    local tempWarpCode = postWarpCode
    postWarpCode = 1
    if HotkeyWarpGeneral(0) == 0 then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 1 end
        return
    end
    writeDouble(varCheckFlag,0)
    writeInteger(varGotoFrame,23)
    writeDouble(varCheckX, 9250)
    writeDouble(varCheckY, 1600)
end

--Mantalith
function HotkeyWarp2()
    local tempWarpCode = postWarpCode
        postWarpCode = 2
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 2 end
        return
    end
    writeDouble(varCheckFlag, 2)
    writeDouble(varCheckX, 3400)
    writeDouble(varCheckY, 200)
    writeInteger(varGotoFrame, 28)
end

--Robopanther
function HotkeyWarp3()
    local tempWarpCode = postWarpCode
        postWarpCode = 3
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 3 end
        return
    end

    writeDouble(varCheckFlag, -1)
    writeDouble(varMeter, 0)
    writeDouble(varCheckX, 11400)
    writeDouble(varCheckY, 200)
    writeInteger(varGotoFrame, 34)

end

--Dail1
function HotkeyWarp4()
    local tempWarpCode = postWarpCode
        postWarpCode = 4
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 4 end
        return
    end
    writeInteger(varGlobalFlags, 117)
    writeDouble(varCheckFlag, -1)
    writeInteger(varGotoFrame, 35)
end

-- Jade Creek Boss
function HotkeyWarp5()
    local tempWarpCode = postWarpCode
        postWarpCode = 5
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 5 end
        return
    end

    writeDouble(varCheckFlag, 2)
    writeDouble(varCheckX, 10200)
    writeDouble(varCheckY, 600)
    writeInteger(varGotoFrame, 43)
end

--Thermal Base Boss
function HotkeyWarp6()
    local tempWarpCode = postWarpCode
        postWarpCode = 6
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 6 end
        return
    end
    writeDouble(varCheckFlag, 2)
    writeDouble(varCheckX, 1245)
    writeDouble(varCheckY, 808)
    writeInteger(varGotoFrame, 49)
end

--Dail 2
function HotkeyWarp7()
    local tempWarpCode = postWarpCode
        postWarpCode = 7
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 7 end
        return
    end
    writeDouble(varCheckFlag, -1)
    writeInteger(varGotoFrame, 64)
    writeDouble(varCheckX, 14700)
    writeDouble(varCheckY, 2200)
    writeInteger(varGlobalFlags, 3)
end

--FD1 Boss
function HotkeyWarp8()
    local tempWarpCode = postWarpCode
        postWarpCode = 8
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 8 end
        return
    end
    writeDouble(varCheckFlag, 2)
    writeDouble(varCheckX, 15775)
    writeDouble(varCheckY, 2098)
    writeInteger(varGotoFrame, 66)
end

-- Dreadbox
function HotkeyWarp9()
    local tempWarpCode = postWarpCode
        postWarpCode = 9
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 9 end
        return
    end
    writeDouble(varCheckFlag, 3)
    writeDouble(varCheckX, 2839)
    writeDouble(varCheckY, 2162)
    writeInteger(varGotoFrame, 67)
end

-- FD2 Boss
function HotkeyWarp10()
    local tempWarpCode = postWarpCode
        postWarpCode = 10
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 10 end
        return
    end
    writeDouble(varCheckFlag, 4)
    writeDouble(varCheckX, 7400)
    writeDouble(varCheckY, 4800)
    writeInteger(varGotoFrame, 68)
end

-- FD3 Boss
function HotkeyWarp11()
    local tempWarpCode = postWarpCode
        postWarpCode = 11
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 11 end
        return
    end
    writeInteger(varGlobalFlags, 7)
    writeDouble(varCheckFlag, 3)
    writeDouble(varCheckX, 13320)
    writeDouble(varCheckY, 1298)
    writeDouble(varShield, 2)
    writeDouble(varShieldHP, 0)
    writeInteger(varGotoFrame, 70)
end

-- Brevon 1
function HotkeyWarp12()
    local tempWarpCode = postWarpCode
        postWarpCode = 12
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 12 end
        return
    end
    writeDouble(varCheckFlag, 0)
    writeDouble(varShield, 2)
    writeInteger(varGotoFrame, 72)
    writeInteger(varGlobalFlags, 12)
end

-- Brevon2
function HotkeyWarp13()
    local tempWarpCode = postWarpCode
        postWarpCode = 13
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 13 end
        return
    end
    writeDouble(varCheckFlag, 2)
    writeDouble(varCheckX, 2496)
    writeDouble(varCheckY, 306)
    writeInteger(varGotoFrame, 72)
end

-- Brevon3
function HotkeyWarp14()
    local tempWarpCode = postWarpCode
        postWarpCode = 14
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
    if inputBreakpointIsActive <= -20 then postWarpCode = 14 end
        return
    end
    writeDouble(varCheckFlag, 3)
    writeDouble(varCheckX, 2550)
    writeDouble(varCheckY, 306)
    writeInteger(varGotoFrame, 72)
    writeInteger(varGlobalFlags, 12)
end

--Custom Checkpoint Functions

--Custom checkpoint variables
customCharacter = 0
customFrame = getProperty(FTrainerMain.BCustomFrame,"Text")
customCheckX = getProperty(FTrainerMain.BCustomX,"Text")
customCheckY = getProperty(FTrainerMain.BCustomY,"Text")
customCheckFlag = 1
customShield = getProperty(FTrainerMain.BCustomShield,"ItemIndex")
customShieldHP = getProperty(FTrainerMain.BCustomShieldHP,"ItemIndex")
customMeter = 0
customCycle = 0
customLock = 1
statusText = getProperty(FTrainerMain.CustomStatus,"Caption")
customHint = getProperty(FTrainerMain.CustomStatus,"Hint")
customHealth = 14
customSpeedToggle = false
customCycleToggle = false
customMeterToggle = false
customSpecialToggle = false
customSpeedX = 0
customSpeedY = 0
customAdvancedCycle = 0
customAdvancedMeter = 0


-- Sets checkpoint at the beginning of current screen, as if the player is just entering it
function HotkeyWarpCustom1()
    if ReattachFP(0) == 0 then return end
    t = readInteger(varFrame)
    h = 0

    if(has_value(arrayFirstFrames,t)== true) then h = 1 end
    if(has_value(arrayNextFrames,t)== true) then h = 2 end

    if(h == 0) then
        setProperty(FTrainerMain.CustomStatus,"Caption","Cannot set checkpoint on frame " .. t)
        setProperty(FTrainerMain.CustomStatus,"ShowHint", false)
    end
    setProperty(FTrainerMain.BCustomX,"Text","0")
    setProperty(FTrainerMain.BCustomY,"Text","0")
    --if current frame belongs to the FirstFrames array, set checkpoint as a stage beginning point.
    if(h == 1) then
        customFrame = t
        customCheckFlag = 1
        customMeter = 0
        customCycle = 0
    end
    --if current frame belongs to the FollowFrames array, set checkpoint as entering a new screen
    if(h == 2) then
        customFrame = t
        customCheckFlag = -1
        customMeter = 100
        customCycle = 0
    end

    --workaround to make my life easier with the submarine room
    if customFrame == 42 then customCycle = 730 end

    --resets global cycles for the entire stage if you play from the beginning
    if customMeter == 0 then customCycle = 0 end

    customShield = getProperty(FTrainerMain.BCustomShield,"ItemIndex")
    customShieldHP = getProperty(FTrainerMain.BCustomShieldHP,"ItemIndex")
    --if customShield == 0 then setProperty(FTrainerMain.BCustomShieldHP,"Enabled",false)
    --else setProperty(FTrainerMain.BCustomShieldHP,"Enabled",true) end
    --Applies advanced options
    ApplyAdvancedCustom()

    statusText = "Set up at start of frame ".. t
    setProperty(FTrainerMain.CustomStatus,"Caption",statusText)
    UpdateStatusHint()
end

-- Sets custom checkpoint at current player position.
function HotkeyWarpCustom2()
    if ReattachFP(0) == 0 then return end
    t = readInteger(varFrame)
    h = 0;
    if(has_value(arrayFirstFrames,t)== true) then h = 1 end
    if(has_value(arrayNextFrames,t)== true) then h = 2 end
    if (h==0) then
        setProperty(FTrainerMain.CustomStatus,"Caption","Cannot set checkpoint on frame " .. t)
        setProperty(FTrainerMain.CustomStatus,"ShowHint", false)
        setProperty(FTrainerMain.BCustomFrame,"Text",readInteger(varFrame))
        setProperty(FTrainerMain.BCustomX,"Text",Round1(readDouble(varPosX)))
        setProperty(FTrainerMain.BCustomY,"Text",Round1(readDouble(varPosY)))
        return
    end

    customFrame = t
    customCheckX = readDouble(varPosX)
    customCheckY = readDouble(varPosY)
    customCheckFlag = readDouble(varCheckFlag)
    customMeter = 100
    customShield = readDouble(varShield)
    customShieldHP = readDouble(varShieldHP)

    if(customCheckFlag == 1) then customCheckFlag = 2 end
    statusText = "Set up at (".. Round1(customCheckX).." , "..Round1(customCheckY)..") on frame " .. t
    setProperty(FTrainerMain.CustomStatus,"Caption", statusText)
    ApplyAdvancedCustom()
    UpdateStatusHint()

    --Updates textboxes with the player's current position
    setProperty(FTrainerMain.BCustomFrame,"Text",customFrame)
    setProperty(FTrainerMain.BCustomX,"Text",Round1(customCheckX))
    setProperty(FTrainerMain.BCustomY,"Text",Round1(customCheckY))
    setProperty(FTrainerMain.BCustomShield,"ItemIndex",customShield)
    setProperty(FTrainerMain.BCustomShieldHP,"ItemIndex",customShieldHP)
end

-- Applies checkpoint with values chosen on editboxes
-- return value is false if warp could not be completed.
function HotkeyWarpCustom3()
    if ReattachFP(0) == 0 then return false end
    t = tonumber(getProperty(FTrainerMain.BCustomFrame,"Text"))
    h = 0;
    if has_value(arrayFirstFrames,t) then h = 1 end
    if has_value(arrayNextFrames,t) then h = 2 end
    if h==0 then
        setProperty(FTrainerMain.CustomStatus,"Caption","Cannot set checkpoint on frame " .. t)
        setProperty(FTrainerMain.CustomStatus,"ShowHint", false)
        return false
    end

    customFrame = t
    customCheckX = tonumber(getProperty(FTrainerMain.BCustomX,"Text"))
    customCheckY = tonumber(getProperty(FTrainerMain.BCustomY,"Text"))
    if isempty(customCheckX) or isempty(customCheckY) then
         setProperty(FTrainerMain.CustomStatus,"Caption","Invalid Parameters")
         setProperty(FTrainerMain.CustomStatus,"ShowHint", false)
         return
    end
    customShield = getProperty(FTrainerMain.BCustomShield,"ItemIndex")
    customShieldHP = getProperty(FTrainerMain.BCustomShieldHP,"ItemIndex")
    customCheckFlag = 2
    --shield health fix for 1.21.5
    --if FPVersion == 3 then customShieldHP = customShieldHP - 1 end

    --Workarounds to bypass flag-specific triggers mid stages
    if(customFrame == 41 or customFrame == 21) and customCheckX >= 9000 then customCheckFlag = 10 end
    if customFrame == 26 and customCheckX >= 7500 then customCheckFlag = 10 end
    if customFrame == 71 and customCheckX >= 2250 then customCheckFlag = 4 end
    if customFrame == 62 and customCheckX >= 3200 then customCheckFlag = 5 end
    if customFrame == 68 and customCheckX >= 7200 then customCheckFlag = 4 end

    --if customFrame == 25 then customCheckFlag = -1 end

    customCycle = readDouble(varGlobalCycle)

    --set checkpoint flag straight to beginning of screen if posX is 0
    if (customCheckX == 0) then
        if(h==1) then
            customCheckFlag = 1
            customMeter = 0
            setProperty(FTrainerMain.BCustomY,"Text","0")
        else
            customCheckFlag = -1
            customMeter = 100
            setProperty(FTrainerMain.BCustomY,"Text","0")
        end
        statusText = "Set up at start of frame ".. t
    --sets checkpoint flag normally if it isn't
    else
        customMeter = 100
        statusText = "Set up at (".. Round1(customCheckX).." , "..Round1(customCheckY)..") on frame " .. t
    end

    --resets global cycles for the entire stage if you play from the beginning
    if customMeter == 0 then customCycle = 0 end

    setProperty(FTrainerMain.CustomStatus,"Caption",statusText)
    ApplyAdvancedCustom()
    UpdateStatusHint()
    return true
end

--Apply custom checkpoint warps
function WarpCustom()
    local tempWarpCode = postWarpCode
    postWarpCode = 15
    if (HotkeyWarpGeneral(0) == 0) then
        postWarpCode = tempWarpCode
        if inputBreakpointIsActive <= -20 then postWarpCode = 15 end
        return
    end
    writeDouble(varCheckFlag, customCheckFlag)
    writeDouble(varCheckX, customCheckX)
    writeDouble(varCheckY, customCheckY)
    writeInteger(varGotoFrame, customFrame)
    writeDouble(varMeter, customMeter)
    writeDouble(varShield, customShield)
    writeDouble(varShieldHP, customShieldHP)
    writeDouble(varGlobalCycle, customCycle)
    writeDouble(varHealth, customHealth)

    --resets RM switches room status
    if customFrame == 24 or customFrame == 25 then writeInteger(varGlobalFlags, 1) end

    --resets SB ships status
    if customFrame == 35 then writeInteger(varGlobalFlags,1) end

    --skips FD3 boss cutscene
    if customFrame == 70 or customFrame == 69 then writeInteger(varGlobalFlags, 5) end

    --skips FN miniboss cutscene (for Lilac adventure mode)
    if customFrame == 29 or customFrame == 30 or customFrame == 31 then writeInteger(varGlobalFlags, 128) end

    --skips Lilac SB miniboss cutscene
    if customFrame == 36 then writeInteger(varGlobalFlags, 129) end
end

--Opens Advanced Custom Warp form
function OpenAdvancedWarp()
    FTrainerCustom.show()
end

--Updates Advanced Custom Warp Options
function UpdateAdvancedWarpOptions()
    --speed x
    local x = getProperty(FTrainerCustom.CEEdit1,"Text")
    if isempty(x) then customSpeedX = 0
    else
        x = tonumber(x)
        if isempty(x) then customSpeedX = 0
        else customSpeedX = x end
    end
    --speed y
    x = getProperty(FTrainerCustom.CEEdit2,"Text")
    if isempty(x) then customSpeedY = 0
    else
        x = tonumber(x)
        if isempty(x) then customSpeedY = 0
        else customSpeedY = x end
    end
    --Global Cycle
    x = getProperty(FTrainerCustom.CEEdit3,"Text")
    if isempty(x) then customAdvancedCycle = 0
    else
        x = tonumber(x)
        if isempty(x) then customAdvancedCycle = 0
        else
            if x < 0 then x = 0 end
            customAdvancedCycle = math.floor(x)
        end
    end
    --Meter
    x = getProperty(FTrainerCustom.CEEdit4,"Text")
    if isempty(x) then customAdvancedMeter = 0
    else
        x = tonumber(x)
        if isempty(x) then customAdvancedMeter = 0
        else
            if x < 0 then x = 0 end
            if x > 100 then x = 100 end
            customAdvancedMeter = x
        end
    end
    --update Toggles
    customSpeedToggle = getProperty(FTrainerCustom.CECheckbox1,"Checked")
    customCycleToggle = getProperty(FTrainerCustom.CECheckbox2,"Checked")
    customMeterToggle = getProperty(FTrainerCustom.CECheckbox3,"Checked")
    customSpecialToggle = getProperty(FTrainerCustom.CECheckbox4,"Checked")
    return
end

--Reads current character state to fill
function GetAdvancedCustomState()
    if ReattachFP(0) == 0 then return end
    local x = readDouble(varSpeedX)
    if not isempty(x) then setProperty(FTrainerCustom.CEEdit1,"Text",Round1(x)) end
    x = readDouble(varSpeedY)
    if not isempty(x) then setProperty(FTrainerCustom.CEEdit2,"Text",Round1(x)) end
    x = readDouble(varGlobalCycle)
    if not isempty(x) then setProperty(FTrainerCustom.CEEdit3,"Text",math.floor(x)) end
    x = readDouble(varMeter)
    if not isempty(x) then setProperty(FTrainerCustom.CEEdit4,"Text",Round1(x)) end

    setProperty(FTrainerCustom.CECheckbox1,"Checked",true)
    setProperty(FTrainerCustom.CECheckbox2,"Checked",true)
    setProperty(FTrainerCustom.CECheckbox3,"Checked",true)
    --test for special item
    local tempboost = readDouble(varCharacterB) == 0 or readDouble(varCharacterB) == 4
    x = readInteger(varSuperBoost)
    if readDouble(varCharacterB) == 0 then
        if isempty(x) then tempboost = false end
        --else tempboost = tempboost and (x & 0x100 == 256) end
        --attempt to rewrite condition in a way the linter recognizes as correct.
        if math.floor(x/256) % 2 == 0 then tempboost = false end

    end
    x = readDouble(varBlock)
    if readDouble(varCharacterB) == 4 then
        if isempty(x) then tempboost = false
        else tempboost = tempboost and (x == 1) end
    end
    setProperty(FTrainerCustom.CECheckbox4,"Checked",tempboost)
    ApplyAdvancedCustom()
    return
end

--Applies advanced custom changes after setting up a custom warp
function ApplyAdvancedCustom()
    if customCycleToggle then
        customCycle = customAdvancedCycle
    end
    if customMeterToggle then
        customMeter = customAdvancedMeter
    end
end



--Updates the status text with current custom warp information
function UpdateCustomStatus()
    setProperty(FTrainerMain.CustomStatus,"Caption", statusText)
    setProperty(FTrainerMain.CustomStatus,"Hint",customHint)
    setProperty(FTrainerMain.CustomStatus,"ShowHint",true)
end

-- Updates status hint text(with extra custom warp data)
function UpdateStatusHint()
    if customShield == 0 then text1 = "No shield" end
    if customShield == 1 then text1 = "Wood shield with " .. math.floor(customShieldHP) +1 .. " hitpoints" end
    if customShield == 2 then text1 = "Fire shield with " .. math.floor(customShieldHP) +1 .. " hitpoints" end
    if customShield == 3 then text1 = "Metal shield with " .. math.floor(customShieldHP) +1 .. " hitpoints" end
    if customShield == 4 then text1 = "Water shield with " .. math.floor(customShieldHP) +1 .. " hitpoints" end
    if customShield == 5 then text1 = "Earth shield with " .. math.floor(customShieldHP) +1 .. " hitpoints" end

    --if customLock == 1 then text2 = "no input unlock"
    --else text2 = "inputs unlocked" end

    text3 = "Global cycle is " .. customCycle

    --customHint = text1 .. ", " .. text2 .. "\n" .. text3
    customHint = text1 .. "\n" .. text3

    setProperty(FTrainerMain.CustomStatus,"Hint", customHint)
    setProperty(FTrainerMain.CustomStatus,"ShowHint", true)
end




--Several functions related to misc hotkeys for the trainer

--Preliminary testing and attributions before any misc hotkey function
function MiscButtonGeneral()
    --if(checkbox_getState(FTrainerMain.CECheckbox3) == 0) then
    if ReattachFP(0) == 0 then return 0 end
    if not compareTopWindow() then
        return 0
    end
    local t = readDouble(varIgt)
    if not isempty(t) then
        if t < 600000 then
            writeDouble(varIgt,t+600000)
        end
    end
    writeDouble(varCrystals, 400)
    return 1
end

--Changes character of choice for warps
function CEComboBox1Change()
    customCharacter = getProperty(FTrainerMain.CEComboBox1,"ItemIndex")
    if customCharacter > 0 then customCharacter = customCharacter + 1 end
end

--Refills health, meter and bike health
function RefillStats()
    if MiscButtonGeneral() == 0 then return end
    writeDouble(varMeter, miscMeter)
    writeDouble(varHealth, miscHealth)
    if not isempty(varBikeHealth) then writeDouble(varBikeHealth,miscBike) end
end

--Instantly grants a max speed boost
function SpeedBoost()
    if MiscButtonGeneral() == 0 then return end

    if readDouble(varSpeedX)>=0 then
        writeDouble(varSpeedX,miscSpeed)
    else
        writeDouble(varSpeedX, (-1) * miscSpeed)
    end
end

--Disables the input lock
function InputUnlock()
    if MiscButtonGeneral() == 0 then return end
    writeDouble(varInputLock,0)
end

--Alternates between Carol and Carol+Bike or grants Lilac Super Dragon Boost or grants Milla a block
function SpecialItem()
    if MiscButtonGeneral() == 0 then return end
    character = readDouble(varCharacterB)
    if isempty(character) then return end
    --if readDouble(varCharacterB) < 2 or readDouble(varCharacterB) > 3 then
    if character > 4 then
        return
    end
    if character == 2 then
        writeDouble(varCharacterB, 3)
        writeDouble(varCharacter, 3)
        writeDouble(varBikeHealth, 3)
    end
    if character == 3 then
        writeDouble(varCharacterB, 2)
        writeDouble(varCharacter, 2)
    end
    if character == 0 then
        writeInteger(varSuperBoost,256)
        writeDouble(varMeter,100)
    end
    if character == 4 then
        specialItemBlock = 2
    end
end

--Instantly moves the character to the position selected by the custom warp coordinates
-- TODO: make number validation checks
function InstantMove()
    if MiscButtonGeneral() == 0 then return end
    writeDouble(varTrueX, getProperty(FTrainerMain.BCustomX,"Text"))
    writeDouble(varTrueY, getProperty(FTrainerMain.BCustomY,"Text"))
end

function ExplodeForNoReason()
    if MiscButtonGeneral() == 0 then return end
    TriggerExplode()
end

--retrieves the trainer's directory
ftrainerDirectory = nil
--test for pointers to see if the game is opened.
-- if not, attempts to open game.
-- returns 3 if the game was properly recognized, 0 otherwise
-- return value is used by many functions to check if they should run or not.
--TODO: change this value to just 1
-- parameters: 1 if it's being ran from the beginning of the script, 0 otherwise.
-- values > 2: used to set manually the game version, for full TASes
function ReattachFP(m)
    --no need to check again if the game has already been opened
    --for a full game TAS
    if playbackFromStart then return 1 end

    --gets game and trainer's directory locations.
    if m == 1 then
        ftrainerDirectory = TrainerOrigin
        if isempty(ftrainerDirectory) then
            ftrainerDirectory = io.popen"cd":read'*l'
        end
    end

    if not isempty(readInteger(varGlobalCycle)) then
        return 1
    end
    --before attempting to open any fp.exe on the list, go for
    --the fp.exe that's on the same directory as ftrainerDirectory
    --isGameOpenedOnFolder checks if the trainer is on the game's root folder and attempts to open it.
    isGameOpenedOnFolder = false
    -- attempts to attach to the game
    openProcess("FP.exe")
    -- checks if the trainer is on the same directory as the game
    if not isempty(ftrainerDirectory) and getOpenedProcessID() == 0 then
        createProcess(ftrainerDirectory .. "FP.exe",nil,false,false)
        isGameOpenedOnFolder = true
    end
    if getOpenedProcessID() == 0 then FPVersion = 0
    else FPVersion = readGameVersion(isGameOpenedOnFolder) end
    --if game could not be attached to, changes window text to
    -- error message and exits.
    if FPVersion == 0 then
        setProperty(FTrainerMain,"Caption",FPTrainerTitle .. " (not attached to game)")
        return 0
    end

    --NOTE: at this point it's assuming game is always going to be opened.
    setProperty(FTrainerMain,"Caption",FPTrainerTitle)
    debugProcess(0)

    debug_setBreakpoint(varInputBreak)
    debug_setBreakpoint(varFFBreak)
    debug_setBreakpoint(varPBreak)

    --TODO: put new setbreakpoint here!!

    -- reapplies currently selected mods
    -- refresh index dictionary

    hitBreakPointsIndex = {}
    for i = 1,#hitBreakPoints do
         hitBreakPointsIndex[tostring(getAddress(hitBreakPoints[i][1]))] = i
    end

    if miscSpeedScreen then
        ShowSpeedOnScreen() end
    if miscHealthScreen then
        ShowHealthOnScreen() end
    if miscMovement then
        ToggleMiscMovement() end
    if miscInvincibility then
        ToggleInvincibility() end
    if miscSuperdog then
        ToggleSuperdog() end
    if miscInstantDeath then
        ToggleInstantDeath() end
    if miscLimitedLives then
        ToggleLimitedLives() end
    if miscCameraLock then
        ToggleCameraLock() end

    return 1
end

--returns currently recognized game version index. 0 means no game recognized.
function readGameVersion(folder)
    if folder then
        return 3
    end
    if not isempty(readInteger(varGlobalCycle)) then return 3 end
    return 0
end

--Returns true if the current window on top is the game the trainer is attached to
function compareTopWindow()
    return getWindowProcessID(getForegroundWindow()) == getOpenedProcessID() or inputBreakpointIsActive == -1 or inputBreakpointIsActive == -2
end




--Key customization functions

--Reverts key configuration to the default
function setDefaultKeys()
    local temp = 1
    S = FTrainerMain.CEListBox1.getItems()
    while temp <= hKeyLimitTrue do
        if HotkeyValue[temp] == 0 then
            hFunc[temp].setKeys(nil)
            S.setString(temp-1,HotkeyText[temp] .. " - None")
        else
            hFunc[temp].setKeys(HotkeyValue[temp])
            S.setString(temp-1,HotkeyText[temp] .. " - " .. convertKeyComboToString(hFunc[temp].getKeys()))
        end
        temp = temp + 1
     end
     setProperty(FTrainerMain.CEListBox1,"Items",S)
     showMessage("Key config set to default")
end

--Sets key configuration to the opened file values
function setCustomKeys()
    temp = 1
    S = FTrainerMain.CEListBox1.getItems()
    while temp <= hKeyLimitTrue do
        if HotkeyValue[temp] == 0 then
            hFunc[temp].setKeys(nil)
            S.setString(temp-1,HotkeyText[temp] .. " - None")
        else
            hFunc[temp].setKeys(HotkeyValue[temp])
            S.setString(temp-1,HotkeyText[temp] .. " - " .. convertKeyComboToString(hFunc[temp].getKeys()))
        end
        temp = temp + 1
    end
    setProperty(FTrainerMain.CEListBox1,"Items",S)
end


--Open and verify file to set keys
function readKeys(sender,filename)
    --open file, or use previously opened file.
    if isempty(filename) then
        load_dialog = createOpenDialog(self)
        load_dialog.InitalDir = ftrainerDirectory
        load_dialog.Title = "Open Key Values File"
        load_dialog.execute()
        f = io.open(load_dialog.FileName)
    else f = io.open(filename) end

    if f == nil then
        showMessage("Could not read file.")
        return
    end

    --read the file values and abort if there are not enough key values on the file
    local temp = 1
    while temp <= hKeyLimitTrue do
        while true do
                local value = f:read("*line")
                if isempty(value) then
                    HotkeyValue[temp] = 0
                    break
                end
                if not isempty(tonumber(value)) then
                    HotkeyValue[temp] = tonumber(value)
                    break
                end
            end
        temp = temp + 1
    end
    f:close()
    setCustomKeys()
end

--Changes a single key configuration, chosen from the list
function changeKeysFromList()
         keyitem = FTrainerMain.CEListBox1.getItemIndex() + 1
         if keyitem == 0 then
            showMessage("Please select an item below.")
            return
         end
         changeHotkeyKeys(hFunc[keyitem])
         S = FTrainerMain.CEListBox1.getItems()
         if hFunc[keyitem].getKeys() == nil then
            S.setString(keyitem-1,HotkeyText[keyitem] .. " - None")
         else
             S.setString(keyitem-1,HotkeyText[keyitem] .. " - " .. convertKeyComboToString(hFunc[keyitem].getKeys()))
         end
         setProperty(FTrainerMain.CEListBox1,"Items",S)
end


--Saves hotkey values in a file, similar to the default one.
function saveKeys()

    load_dialog = createOpenDialog(self)
    load_dialog.InitalDir = ftrainerDirectory
    load_dialog.Title = "Save Key Values File"
    load_dialog.Options = "[ofOverwritePrompt]"
    load_dialog.execute()
    f = io.open(load_dialog.FileName,"w")
    if f == nil then
        showMessage("Could not save file.")
        return
    end

    saveText = "commands\n"
    local temp = 1
    while temp <= hKeyLimitTrue do
        saveText = saveText .. HotkeyText[temp] .. "\n"
        if isempty(hFunc[temp].getKeys()) then
            saveText = saveText .. "0\n"
        else
            saveText = saveText .. hFunc[i].getKeys() .. "\n"
        end
        temp = temp + 1
    end

    f:write(saveText)
    f:close()
    showMessage("File was succesfully saved.")
end

function LastUsedWarp()
    if postWarpCode == 0 then return end
    hFunc[postWarpCode].onHotkey()
end

--Key customization related variables
hKeyLimit = 20
hKeyLimitTrue = 29
HotkeyValueDefault = {VK_1,VK_2,VK_3,VK_4,VK_5,VK_6,VK_7,VK_8,VK_9,VK_0,VK_OEM_MINUS,VK_OEM_PLUS,VK_O,VK_P,VK_F1,0,VK_Q,VK_W,VK_E,VK_OEM_5,0,VK_T,0,0,0,0,0,0,0}
HotkeyValue = {VK_1,VK_2,VK_3,VK_4,VK_5,VK_6,VK_7,VK_8,VK_9,VK_0,VK_OEM_MINUS,VK_OEM_PLUS,VK_O,VK_P,VK_F1,0,VK_Q,VK_W,VK_E,VK_OEM_5,0,VK_T,0,0,0,0,0,0,0}
HotkeyText = {"DV Boss Room","RM Boss Warp","FN Boss Warp","SB Boss Warp","JC Boss Warp","TB Boss Warp","BG Boss Warp","FD1 Boss Warp","Dreadbox Warp","FD2 Boss Warp","FD3 Boss Warp","Brevon1 Warp","Brevon2 Warp","Brevon3 Warp",
              "Custom Warp","Last Used Warp",
              "Refill","Speed Boost","Special Item","Instant Move","Unlock Inputs","Explode",
              "Start Playback","Pause Playback","Advance Playback","Stop Playback","Speed Up Game","Speed Down Game","Start Recording"}

HotkeyWarpToggle = 0

--TODO: find a way to send an argument alongside,
--so you can have only one function instead of 15
function HotkeyWarpToggle1()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 1
end

function HotkeyWarpToggle2()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 2
end
function HotkeyWarpToggle3()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 3
end
function HotkeyWarpToggle4()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 4
end
function HotkeyWarpToggle5()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 5
end
function HotkeyWarpToggle6()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 6
end
function HotkeyWarpToggle7()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 7
end
function HotkeyWarpToggle8()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 8
end
function HotkeyWarpToggle9()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 9
end
function HotkeyWarpToggle10()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 10
end
function HotkeyWarpToggle11()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 11
end
function HotkeyWarpToggle12()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 12
end
function HotkeyWarpToggle13()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 13
end
function HotkeyWarpToggle14()
    if ReattachFP(0) == 0 then return end
    HotkeyWarpToggle = 14
end
function HotkeyWarpToggle15()
         if ReattachFP(0) == 0 then return end
         HotkeyWarpToggle = 15
end

-------------------------------------------------
--Tool Assist related variables and functions
readInputsFromDisplay = false
inputPlaybackFile = nil
playbackFileName = nil    --memorizes last filename used
inputPlaybackLines = 0
inputPlaybackCommLines = 0 --Lines of commentary
inputPlaybackPauseFrame = -1  --frame count where the playback is forcefully paused
inputBreakpointIsActive = 0   --debug status for reference
lastPlaybackInput = {0,0,0,0,0,0,0,0}
playbackFromStart = false
recordingText = nil
recordingFile = nil
fftoggle = 0  --fast forward control
frameadvancetrigger = 0 --frameadvance trigger control
--1 = yes, 0 = no

postWarpCode = 15 --will be used to treat post warp attributions
--custom warp is the default one.

--for the milla block hotkey
specialItemBlock = 0

--[[
inputBreakpointIsActive
0 - not active
1 - game paused
2 - running playback
3 - game paused mid playback
4 - recording
5 - recording and paused
-1 - transition to start playback
-2 - transition to start recording
10a+b for positive a - a frames of post playback attributions, b is listed above
10a+b for negative a - a frames of pre playback attributions, b is listed above
]]--

--Changes the process speed using CE speedhack (which rarely works for some reason)
function CEComboBox2Change()
    if getOpenedProcessID() == 0  then return end
    if getProperty(FTrainerMain.CEComboBox2,"ItemIndex") == 0 then
        speedhack_setSpeed(0.25)
    end
    if getProperty(FTrainerMain.CEComboBox2,"ItemIndex") == 1 then
        speedhack_setSpeed(0.5)
    end
    if getProperty(FTrainerMain.CEComboBox2,"ItemIndex") == 2 then
        speedhack_setSpeed(1)
    end
    if getProperty(FTrainerMain.CEComboBox2,"ItemIndex") == 3 then
        speedhack_setSpeed(2)
    end
    if getProperty(FTrainerMain.CEComboBox2,"ItemIndex") == 4 then
        speedhack_setSpeed(5)
    end
end

--Hotkey functions to manipulate the above function
function ChangeGameSpeedUp()
    if getOpenedProcessID() == 0  then return end
    h = getProperty(FTrainerMain.CEComboBox2,"ItemIndex")
    if h < 4 then
        setProperty(FTrainerMain.CEComboBox2,"ItemIndex",h+1)
    end
    CEComboBox2Change()
end

function ChangeGameSpeedDown()
        if getOpenedProcessID() == 0  then return end
        h = tonumber(getProperty(FTrainerMain.CEComboBox2,"ItemIndex"))
        if h > 0 then
            setProperty(FTrainerMain.CEComboBox2,"ItemIndex",h-1)
        end
        CEComboBox2Change()
end

--gamepausetrigger is activated with tas commands and is set up to
--keep the game unpaused at the end
gamePauseTrigger = false
gameUnpauseOnInput = false
--Pauses and unpauses the game, based on playback status
function GamePause()
    -- state 0: game is unpaused and about to be paused.
    if inputBreakpointIsActive == 0 then
        inputBreakpointIsActive = 1
        if inputPlaybackLines == 0 then
           setProperty(FTrainerMain.ToolStatus,"Caption","Game Paused")
        else
            if inputPlaybackCommLines == 0 then
               setProperty(FTrainerMain.ToolStatus,"Caption","Game Paused on frame " .. inputPlaybackLines)
            else
                setProperty(FTrainerMain.ToolStatus,"Caption","Game Paused on frame " .. inputPlaybackLines  .. " (" .. inputPlaybackLines + inputPlaybackCommLines .. ")")
            end
        end
        setProperty(FTrainerMain.TPauseButton,"Caption","Unpause")
        if getProperty(FTrainerDataview,"Visible") then UpdateAdvancedDataview() end

    --state 1: game is paused and about to be unpaused.
    else if inputBreakpointIsActive == 1 then
        inputBreakpointIsActive = 0
        setProperty(FTrainerMain.ToolStatus,"Caption","Unpaused")
        setProperty(FTrainerMain.TPauseButton,"Caption","Pause")

    --state 2: game is running a playback and about to be paused.
    else if inputBreakpointIsActive == 2 then
        inputBreakpointIsActive = 3
        fftoggle = 0
        if inputPlaybackCommLines == 0 then
           setProperty(FTrainerMain.ToolStatus,"Caption","Paused at frame " .. inputPlaybackLines)
        else
            setProperty(FTrainerMain.ToolStatus,"Caption","Paused at frame " .. inputPlaybackLines .. " (" .. inputPlaybackLines + inputPlaybackCommLines .. ")")
        end
        setProperty(FTrainerMain.TPauseButton,"Caption","Unpause")
        if getProperty(FTrainerDataview,"Visible") then UpdateAdvancedDataview() end

    --state 3: game is running a playback and paused, and about to be unpaused.
    else if inputBreakpointIsActive == 3 then
        inputBreakpointIsActive = 2
        if inputPlaybackPauseFrame == inputPlaybackLines then inputPlaybackPauseFrame = -2 end
        setProperty(FTrainerMain.ToolStatus,"Caption","Resumed playback.")
        setProperty(FTrainerMain.TPauseButton,"Caption","Pause")

    --state 4: game is running a recording and about to be paused.
     else if inputBreakpointIsActive == 4 then
        inputBreakpointIsActive = 5
        if inputPlaybackCommLines == 0 then
           setProperty(FTrainerMain.ToolStatus,"Caption","Game Paused on frame " .. inputPlaybackLines)
        else
            setProperty(FTrainerMain.ToolStatus,"Caption","Game Paused on frame " .. inputPlaybackLines  .. " (" .. inputPlaybackLines + inputPlaybackCommLines .. ")")
        end
        setProperty(FTrainerMain.TPauseButton,"Caption","Unpause")
        if getProperty(FTrainerDataview,"Visible") then UpdateAdvancedDataview() end

    --state 5: game is running a recording and paused, and about to be unpaused.
    else
        inputBreakpointIsActive = 4
        setProperty(FTrainerMain.ToolStatus,"Caption","Unpaused")
        setProperty(FTrainerMain.TPauseButton,"Caption","Pause")
     end end end end end

end

function ToggleGamePause()
    if ReattachFP(0) == 0 then return end
    if inputBreakpointIsActive > 5 or inputBreakpointIsActive < 0 then return end
    gamePauseTrigger = true
end

--Advances a frame in-game if the game is paused
function frameAdvance()
    --state 1: advances a frame in game and keeps state
    if inputBreakpointIsActive == 1 then
        --if frame counter is not running (post playback),
        --do not touch counter.
        applyTInputs()
        if inputPlaybackLines == 0 then
            if readInputsFromDisplay then
              setProperty(FTrainerMain.ToolStatus,"Caption","Advanced with given inputs")
            else
              setProperty(FTrainerMain.ToolStatus,"Caption","Advanced a frame")
            end
        else
        --if frame counter is running post playback (from counter extension),
        --increment it and update value.
            inputPlaybackLines = inputPlaybackLines + 1
            if inputPlaybackCommLines == 0 then
               setProperty(FTrainerMain.ToolStatus,"Caption","Advanced to frame ".. inputPlaybackLines)
            else
                setProperty(FTrainerMain.ToolStatus,"Caption","Advanced to frame ".. inputPlaybackLines  .. " (" .. inputPlaybackLines + inputPlaybackCommLines .. ")")
            end
        end

    --state 3: advances a frame in game and keeps playback state
    else if inputBreakpointIsActive == 3 then --inputBreakpointIsActive = 3
        playbackInputRead()
            --value changes to 1 if playback ended during a frame advance
            if inputBreakpointIsActive == 1 then
                if inputPlaybackCommLines == 0 then
                setProperty(FTrainerMain.ToolStatus,"Caption","Finished reading " .. inputPlaybackLines .. " lines")
            else
                setProperty(FTrainerMain.ToolStatus,"Caption","Finished reading " .. inputPlaybackLines .. " (" .. inputPlaybackLines + inputPlaybackCommLines .. ") lines")
            end
            if not getProperty(FTrainerMain.CECheckbox7,"Checked") then
               inputPlaybackLines = 0
            else inputPlaybackLines = inputPlaybackLines + 1
            end
        else
            if inputPlaybackCommLines == 0 then
                setProperty(FTrainerMain.ToolStatus,"Caption","Paused at frame " .. inputPlaybackLines)
            else
                setProperty(FTrainerMain.ToolStatus,"Caption","Paused at frame " .. inputPlaybackLines .. " (" .. inputPlaybackLines + inputPlaybackCommLines .. ")")
            end
        end

    --state 5: advances a frame in game and keeps recording state
    else --inputBreakpointIsActive = 5
        applyTInputs()
        recordingText = recordingText .. applyRInputs()
        inputPlaybackLines = inputPlaybackLines + 1
        if inputPlaybackCommLines == 0 then
            setProperty(FTrainerMain.ToolStatus,"Caption","Advanced to frame ".. inputPlaybackLines)
        else
            setProperty(FTrainerMain.ToolStatus,"Caption","Advanced to frame ".. inputPlaybackLines  .. " (" .. inputPlaybackLines + inputPlaybackCommLines .. ")")
        end
    end end

    --updates advanced dataview (for all states)
    if getProperty(FTrainerDataview,"Visible") then UpdateAdvancedDataview() end
end

function FrameAdvanceTrigger()
    if ReattachFP(0) == 0 then return end
    if not has_value({1,3,5},inputBreakpointIsActive) then return end
    frameadvancetrigger = 1
end

function CECheckbox5Change()
    readInputsFromDisplay = getProperty(FTrainerMain.CECheckbox5,"Checked")
end

--Apply inputs from the display to the game
function applyTInputs()
    if not readInputsFromDisplay then return end
    if getProperty(FTrainerMain.TButtonUp,"Checked") then
        writeDouble(varInputUp,1000)
    end
    if getProperty(FTrainerMain.TButtonDown,"Checked") then
        writeDouble(varInputDown,1000)
    end
    if getProperty(FTrainerMain.TButtonLeft,"Checked") then
        writeDouble(varInputLeft,1000)
    end
    if getProperty(FTrainerMain.TButtonRight,"Checked") then
        writeDouble(varInputRight,1000)
    end
    if getProperty(FTrainerMain.TButtonA,"Checked") then
        writeDouble(varInputJump,1000)
    end
    if getProperty(FTrainerMain.TButtonB,"Checked") then
        writeDouble(varInputAttack,1000)
    end
    if getProperty(FTrainerMain.TButtonC,"Checked") then
        writeDouble(varInputSpecial,1000)
    end
    if getProperty(FTrainerMain.TButtonP,"Checked") then
        writeDouble(varInputPause,1000)
    end
end

--Automatically checks or unchecks automatic pausing during playback
function TPauseFrameValueChange()
    inputPlaybackPauseFrame = tonumber(getProperty(FTrainerMain.TPauseFrameValue,"Text"))
    if isempty(inputPlaybackPauseFrame) then inputPlaybackPauseFrame = 0 end
    setProperty(FTrainerMain.CECheckbox4,"Checked",true)
end

--Opens an input file and sets breakpoints and counters for playback
function playbackInputs()
    --Attempts to open playback file
    if isempty(playbackFileName) then
        load_dialog = createOpenDialog(self)
        load_dialog.InitalDir = ftrainerDirectory
        load_dialog.Title = "Open Playback File"
        load_dialog.execute()
        playbackFileName = load_dialog.FileName
    end
    inputPlaybackFile = io.open(playbackFileName)
    setProperty(FTrainerMain.CEButton9,"Hint",playbackFileName)

    --aborts if the file path is invalid
    if isempty(inputPlaybackFile) then
        inputBreakpointIsActive = 0
        return
    end

    --Sets variables and state to transition state
    inputPlaybackLines = 0
    inputPlaybackCommLines = 0
    playbackFromStart = false
    fftoggle = 0

    --read header parameters and apply changes here
    if inputFileHeader(inputPlaybackFile,true) == 0 then
        setProperty(FTrainerMain.ToolStatus,"Caption","Error reading file header on line " .. inputPlaybackCommLines + 1)
        return
    end

    if ReattachFP(0) == 0 then return end
    if inputBreakpointIsActive == 3 then
        local t = fftoggle
        local h = inputPlaybackCommLines
        playbackStop()
        inputPlaybackCommLines = h
        fftoggle = t
    end

    if inputBreakpointIsActive == 1 then --or inputBreakpointIsActive == 3 then
        local t = fftoggle
        GamePause()
        fftoggle = t
    end
    if playbackFromStart then
        inputBreakpointIsActive = 100
    else
        inputBreakpointIsActive = -1
    end

    if getProperty(FTrainerMain.CECheckbox4,"Checked") then
        inputPlaybackPauseFrame = getProperty(FTrainerMain.TPauseFrameValue,"Text")
        if isempty(tonumber(inputPlaybackPauseFrame)) then inputPlaybackPauseFrame = 0
        else inputPlaybackPauseFrame = tonumber(inputPlaybackPauseFrame) end
        fftoggle = 1
    else
        inputPlaybackPauseFrame = -1
    end
    setProperty(FTrainerMain.ToolStatus,"Caption","Starting Playback.")
    if fftoggle == 1 then setProperty(FTrainerMain.ToolStatus,"Caption","Fast Forwarding.") end
    setProperty(FTrainerMain.CEButton11,"Caption","Stop")
end

--reads custom warp settings from a file
function ReadCustomWarp(sender,filename)
    if ReattachFP(0) == 0 then return end

    if isempty(filename) then
       load_dialog = createOpenDialog(self)
       load_dialog.InitalDir = ftrainerDirectory
       load_dialog.Title = "Open Custom Warp File"
       load_dialog.execute()
       file = io.open(load_dialog.FileName)
    else file = io.open(filename)
    end
    if isempty(file) then return end

    --reset relevant checkboxes
    setProperty(FTrainerMain.CECheckbox2,"Checked",false)
    setProperty(FTrainerTimer.CECheckbox1,"Checked",false)
    setProperty(FTrainerTimer.CECheckbox2,"Checked",false)
    setProperty(FTrainerTimer.CECheckbox3,"Checked",false)
    setProperty(FTrainerTimer.CECheckbox4,"Checked",false)
    setProperty(FTrainerTimer.CECheckbox6,"Checked",false)
    setProperty(FTrainerTimer.CECheckbox7,"Checked",false)
    setProperty(FTrainerCustom.CECheckbox4,"Checked",false)
    --reads header and apply settings
    if inputFileHeader(file,false) == 0 then
        setProperty(FTrainerMain.CustomStatus,"Caption","Error setting up from file")
        return
    end
    file:close()
end

--save custom warp settings into a file
function SaveCustomWarp()
    --first you have to do a custom warp save...
    if not HotkeyWarpCustom3() then
        showMessage("Invalid Warp parameters, please fix them before saving.")
        return end

    load_dialog = createOpenDialog(self)
    load_dialog.InitalDir = ftrainerDirectory
    load_dialog.Title = "Save Custom Warp File"
    setProperty(load_dialog,"Options","[OverwritePrompt]")
    load_dialog.execute()
    f = io.open(load_dialog.FileName,"w")
    if f == nil then
        return
    end
    saveText = "customwarp\n"

    saveText = saveText .. "character " .. tostring(customCharacter) .. "\n"
    saveText = saveText .. "warp custom " .. tostring(customFrame) .. " " .. tostring(Round3(customCheckX)) .. " " .. tostring(Round3(customCheckY)) .. "\n"
    if customShield ~= 0 then
        saveText = saveText .. "shield " .. tostring(math.floor(customShield)) .. " " .. tostring(math.floor(customShieldHP + 1)) .. "\n"
    end
    if customLock == 0 then
        saveText = saveText .. "unlock\n" end
    if getProperty(FTrainerMain.CECheckbox6,"Checked") then
        if not isempty(tonumber(getProperty(FTrainerMain.BTASSeed,"Text"))) then
           saveText = saveText .. "seed " .. getProperty(FTrainerMain.BTASSeed,"Text") .. "\n"
    end end
    saveText = saveText .. "globalcycle " .. tostring(customCycle) .. "\n"
    if customHealth ~= 14 then
        saveText = saveText .. "health " .. tostring(customHealth) .. "\n" end
    saveText = saveText .. "meter " .. tostring(customMeter) .. "\n"
    --timer
    if miscTimerFrame then
        saveText = saveText .. "timer frame " .. tostring(valTimerFrame) .. "\n" end
    if miscTimerPosX then
        saveText = saveText .. "timer posx " .. tostring(valTimerPosX) .. "\n" end
    if miscTimerFlag then
        saveText = saveText .. "timer check " .. tostring(valTimerFlag) .. "\n" end
    if miscTimerLimit then
        saveText = saveText .. "timerlimit " .. tostring(valTimerLimit/1000) .. "\n" end
    if miscTimerPB then
        saveText = saveText .. "timerlimitpb\n" end
    if customSpeedX ~= 0 then
        saveText = saveText .. "speedX " .. tostring(customSpeedX) .. "\n" end
    if customSpeedY ~= 0 then
        saveText = saveText .. "speedY " .. tostring(customSpeedY) .. "\n" end
    if customSpecialToggle then
        saveText = saveText .. "specialitem\n" end

    f:write(saveText)
    f:close()
    showMessage("File was succesfully saved.")
end

--Same as above, but resetting the saved filename
function playbackInputsAlt()
    local h = playbackFileName
    playbackFileName = nil
    setProperty(FTrainerMain.CEButton9,"Hint",nil)
    playbackInputs()
    if playbackFileName == nil then
        playbackFileName = h
        setProperty(FTrainerMain.CEButton9,"Hint",h)
    end
end

--reads header to set warp and playback settings
--returns 0 on error (todo later)
--isPlaynack:
--true = this is being done to setup a TAS playback
--false = this is being done to setup a custom warp
function inputFileHeader(file,isPlayback)
    --[[open file and start loop, except the file is already opened
    ]]--
    while true do
    --read and split line
        local fileLineSplit = file:read("*line")
        local headerLine = {}
        if isempty(fileLineSplit) then break end
        for word in string.gmatch(fileLineSplit, "[%w%p]+") do
            headerLine[#headerLine+1] = word
        end
        --if first line is the input already, reopen file and keep going
        --this provides support to files that are only input sequences.
        if headerLine[1] == '0' or headerLine[1] == '1' then
            if inputPlaybackCommLines == 0 then
              inputPlaybackFile = io.open(playbackFileName)
              return 1
            else return 0 end
        end

        --ends loop when playback lines start
        if headerLine[1] == "inputs" then
            inputPlaybackCommLines = inputPlaybackCommLines + 1
            return 1
        end

        --applies character choice
        if headerLine[1] == "character" then
            if headerLine[2] == "lilac" then headerLine[2] = "0" end
            if headerLine[2] == "carol" then headerLine[2] = "2" end
            if headerLine[2] == "carolbike" then headerLine[2] = "3" end
            if headerLine[2] == "milla" then headerLine[2] = "4" end
            headerLine[2] = tonumber(headerLine[2])
            if headerLine[2] ~= math.floor(headerLine[2]) then return 0 end
            if headerLine[2] >= 0 and headerLine[2] <= 4 and headerLine[2] ~= 1 then
                if headerLine[2] > 1 then headerLine[2] = headerLine[2] - 1 end
                setProperty(FTrainerMain.CEComboBox1,"ItemIndex",headerLine[2])
                CEComboBox1Change()
            else return 0 end
        end

        --applies difficulty settings
        -- hard = 0, normal = 1, easy = 2 and casual = 3
        if headerLine[1] == "difficulty" then
            if headerLine[2] == "hard" then headerLine[2] = "0" end
            if headerLine[2] == "normal" then headerLine[2] = "1" end
            if headerLine[2] == "easy" then headerLine[2] = "2" end
            if headerLine[2] == "casual" then headerLine[2] = "3" end
            headerLine[2] = tonumber(headerLine[2])
            if isempty(headerLine[2]) then return 0 end
            if headerLine[2] ~= math.floor(headerLine[2]) then return 0 end
            if headerLine[2] >= 0 and headerLine[2] <= 3 then
                writeDouble(varDifficulty,headerLine[2])
            else return 0 end
        end

        --applies warping settings
        if headerLine[1] == "warp" then
            --custom warps
            if headerLine[2] == "none" or headerLine[2] == "false" then
              setProperty(FTrainerMain.CEComboBox3,"ItemIndex",0)
            else
                if headerLine[2] == "custom" then
                    --check if frame value is invalid
                    if isempty(headerLine[3]) or isempty(headerLine[4]) then return 0 end
                    setProperty(FTrainerMain.BCustomFrame,"Text",headerLine[3])
                    if not has_value(arrayFirstFrames,tonumber(headerLine[3])) and not  has_value(arrayNextFrames,tonumber(headerLine[3])) then
                        return 0
                    end
                    setProperty(FTrainerMain.BCustomX,"Text",headerLine[4])
                    --sets checkY to 0 if checkX is 0 as well
                    if tonumber(headerLine[4]) ~= 0 then
                        if isempty(headerLine[5]) then return 0 end
                        setProperty(FTrainerMain.BCustomY,"Text",headerLine[5])
                        --if the optional shield values are available
                        if headerLine[6] and headerLine[7] then
                            if isempty(tonumber(headerLine[6])) or isempty(tonumber(headerLine[7])) then return 0 end
                            headerLine[6] = tonumber(headerLine[6])
                            headerLine[7] = tonumber(headerLine[7])
                            if headerLine[6] < 1 or headerLine[6] > 5 then return 0 end
                            if headerLine[7] < 1 or headerLine[7] > 4 then return 0 end
                            setProperty(FTrainerMain.BCustomShield,"ItemIndex",headerLine[6])
                            setProperty(FTrainerMain.BCustomShieldHP,"ItemIndex",headerLine[7]-1)
                        else
                            setProperty(FTrainerMain.BCustomShield,"ItemIndex",0)
                            setProperty(FTrainerMain.BCustomShieldHP,"ItemIndex",1)
                        end
                    else
                        --same thing as before, but different parameter orders
                        setProperty(FTrainerMain.BCustomY,"Text",0)
                        if headerLine[5] and headerLine[6] then
                            if isempty(tonumber(headerLine[5])) or isempty(tonumber(headerLine[6])) then return 0 end
                            headerLine[5] = tonumber(headerLine[6])
                            headerLine[5] = tonumber(headerLine[6])
                            if headerLine[5] < 1 or headerLine[5] > 5 then return 0 end
                            if headerLine[6] < 1 or headerLine[6] > 4 then return 0 end
                            setProperty(FTrainerMain.BCustomShield,"ItemIndex",headerLine[5])
                            setProperty(FTrainerMain.BCustomShieldHP,"ItemIndex",headerLine[6]-1)
                        else
                            setProperty(FTrainerMain.BCustomShield,"ItemIndex",0)
                            setProperty(FTrainerMain.BCustomShieldHP,"ItemIndex",0)
                        end
                    end
                    --sets type of warp to custom
                    setProperty(FTrainerMain.CEComboBox3,"ItemIndex",1)
                    --makes the header read fail if the custom warp setup fails
                    HotkeyWarpCustom3()
                    if not getProperty(FTrainerMain.CustomStatus,"ShowHint") then return 0 end
                else
                    --default warps
                    if isempty(tonumber(headerLine[2])) then return 0 end

                    headerLine[2] = tonumber(headerLine[2])
                    if headerLine[2] < 1 or headerLine[2] > 14 then return 0 end
                    if headerLine[2] ~= math.floor(headerLine[2]) then return 0 end
                    setProperty(FTrainerMain.CEComboBox3,"ItemIndex",headerLine[2] + 1)
                end
            end
        end

        --customshield
        if headerLine[1] == "shield" then
           if isempty(tonumber(headerLine[2])) or isempty(tonumber(headerLine[3])) then return 0 end
           headerLine[2] = tonumber(headerLine[2])
           headerLine[3] = tonumber(headerLine[3])
           if headerLine[2] ~= math.floor(headerLine[2]) then return 0 end
           if headerLine[3] ~= math.floor(headerLine[3]) then return 0 end
           if headerLine[2] < 1 or headerLine[2] > 5 then return 0 end
           if headerLine[3] < 1 or headerLine[3] > 4 then return 0 end
           setProperty(FTrainerMain.BCustomShield,"ItemIndex",headerLine[2])
           setProperty(FTrainerMain.BCustomShieldHP,"ItemIndex",headerLine[3]-1)

           customShield = headerLine[2]
           customShieldHP = headerLine[3] - 1
           UpdateStatusHint()
        end

        --initial seed
        if headerLine[1] == "seed" then
            if headerLine[2] == "false" then
              setProperty(FTrainerMain.CECheckbox6,"Checked",false)
            else
               if isempty(tonumber(headerLine[2])) then return 0 end
               if tonumber(headerLine[2]) ~= math.floor(tonumber(headerLine[2])) then return 0 end
               setProperty(FTrainerMain.BTASSeed,"Text",headerLine[2])
               setProperty(FTrainerMain.CECheckbox6,"Checked",true)
            end
        end

        --global cycle
        if headerLine[1] == "globalcycle" then
            if isempty(tonumber(headerLine[2])) then return 0 end
            headerLine[2] = tonumber(headerLine[2])
            if headerLine[2] ~= math.floor(headerLine[2]) then return 0 end
            customCycle = headerLine[2]
            UpdateStatusHint()
        end

        --health
        if headerLine[1] == "health" then
            if isempty(tonumber(headerLine[2])) then return 0 end
            headerLine[2] = tonumber(headerLine[2])
            if headerLine[2] < 0 or headerLine[2] > 14 then return 0 end
            customHealth = headerLine[2]
        end

        --meter
        if headerLine[1] == "meter" then
            if isempty(tonumber(headerLine[2])) then return 0 end
            headerLine[2] = tonumber(headerLine[2])
            if headerLine[2] < 0 or headerLine[2] > 100 then return 0 end
            customMeter = headerLine[2]
        end

        --input unlock
        --TODO: add setting for input unlock upon input
        if headerLine[1] == "unlock" then
            --if not isempty(headerLine[2]) then return 0 end
            if headerLine[2] == "false" then
                setProperty(FTrainerMain.CECheckbox2,"Checked",false)
                customLock = 1
            else if headerLine[2] == "true" or isempty(headerLine[2]) then
                setProperty(FTrainerMain.CECheckbox2,"Checked",true)
                customLock = 0
                else return 0 end
            end
        end
        if headerLine[1] == "speedX" then
            setProperty(FTrainerCustom.CECheckbox1,"Checked",true)
            setProperty(FTrainerCustom.CEEdit1,"Text",headerLine[2])
        end
        if headerLine[1] == "speedY" then
            setProperty(FTrainerCustom.CECheckbox1,"Checked",true)
            setProperty(FTrainerCustom.CEEdit2,"Text",headerLine[2])
        end
        --the following parameters are only available when done to setup
        -- a custom warp
        if not isPlayback then
            if headerLine[1] == "timer" then
            --timer stop settings
                if headerLine[2] == "frame" then
                    if isempty(tonumber(headerLine[3])) then return 0 end
                    if not has_value(arrayFirstFrames,tonumber(headerLine[3])) and not has_value(arrayNextFrames,tonumber(headerLine[3])) then
                        return 0
                    end
                setProperty(FTrainerTimer.CEEdit1,"Text",headerLine[3])
                setProperty(FTrainerTimer.CECheckbox1,"Checked",true)
                setProperty(FTrainerTimer.CECheckbox2,"Checked",true)
            end
            if headerLine[2] == "posx" then
                if isempty(tonumber(headerLine[3])) then return 0 end
                setProperty(FTrainerTimer.CEEdit2,"Text",headerLine[3])
                setProperty(FTrainerTimer.CECheckbox1,"Checked",true)
                setProperty(FTrainerTimer.CECheckbox3,"Checked",true)
            end
            if headerLine[2] == "check" then
                if isempty(tonumber(headerLine[3])) then return 0 end
                setProperty(FTrainerTimer.CEEdit3,"Text",headerLine[3])
                setProperty(FTrainerTimer.CECheckbox1,"Checked",true)
                setProperty(FTrainerTimer.CECheckbox4,"Checked",true)
            end
            --extra position for own pointer later
            end
            if headerLine[1] == "timerlimit" then
              if isempty(tonumber(headerLine[2])) then return 0 end
              setProperty(FTrainerTimer.CEEdit5,"Text",headerLine[2])
              setProperty(FTrainerTimer.CECheckbox6,"Checked",true)
            end
            if headerLine[1] == "timerlimitpb" then
                if not isempty(headerLine[2]) then return 0 end
                setProperty(FTrainerTimer.CECheckbox7,"Checked",true)
            end
            if headerLine[1] == "specialitem" then
                if not isempty(headerLine[2]) then return 0 end
                setProperty(FTrainerCustom.CECheckbox4,"Checked",true)
            end
        --the following parameters are only available when done to setup
        -- a playback
        else
            --automatic counter extending
            if headerLine[1] == "extend" then
            --if not isempty(headerLine[2]) then return 0 end
                if headerLine[2] == "false" then
                    setProperty(FTrainerMain.CECheckbox7,"Checked",false)
                else if headerLine[2] == "true" or isempty(headerLine[2]) then
                    setProperty(FTrainerMain.CECheckbox7,"Checked",true)
                else return 0 end
                end
            end

            --initial game speed
            if headerLine[1] == "speed" then
                if isempty(headerLine[2]) then return 0 end
                headerLine[2] = tonumber(headerLine[2])
                if isempty(math.floor(headerLine[2])) then return 0 end
                setProperty(FTrainerMain.CEComboBox2,"ItemIndex",headerLine[2]-1)
                CEComboBox2Change()
            end

            --pause at frame x
            if headerLine[1] == "pause" then
                --TODO: make it default to end of playback
                if isempty(headerLine[2]) then return 0 end
                if headerLine[2] == "false" then
                    setProperty(FTrainerMain.CECheckbox4,"Checked",false)
                else
                    if isempty(tonumber(headerLine[2])) then return 0 end
                    if tonumber(headerLine[2]) ~=  math.floor(tonumber(headerLine[2])) then return 0 end
                    setProperty(FTrainerMain.TPauseFrameValue,"Text",headerLine[2])
                end
            end

            --fast forward toggle
            if headerLine[1] == "fastforward" then
                fftoggle = 1
            end

            --starts TASing right from game boot
            if headerLine[1] == "playfromstart" then
                if isempty(headerLine[2]) then return 0 end
                playbackFromStart = true
                FPVersion = 3
            createProcess(headerLine[2],nil,true,true)
            end
        end

        --end of the while true loop
        --increments line counter and repeats loop
        inputPlaybackCommLines = inputPlaybackCommLines + 1
    end
    -- if isPlayback then return 0
    return 1
end

--Chooses a type of warp to be done before playback begins
function choosePlaybackWarp(i)
    if i == 1 then return 15
    else return i-1
    end
end

--Interrupts playback, paused or not
function playbackStop()
    if ReattachFP(0) == 0 then return end
    --stop recording here; write current string to file
    if inputBreakpointIsActive == 4 or inputBreakpointIsActive == 5 then
        setProperty(FTrainerMain.ToolStatus,"Caption","Finished recording " .. inputPlaybackLines .. " frames")
        if isempty(recordingFile) or isempty(recordingText) then return end
        inputBreakpointIsActive = inputBreakpointIsActive - 4
        inputPlaybackLines = 0
        local f = io.open(recordingFile,"w")
        if not f then return end
        local a = messageDialog('Do you want to save the recording?', mtInformation, mbYes, mbNo)
        if a == 6 then
          f:write(recordingText)
        end
        recordingText = nil
        f:close()
        return

    end
    if inputPlaybackLines == 0 and inputBreakpointIsActive ~= 3 then return end
    setProperty(FTrainerMain.ToolStatus,"Caption","Stopped on frame " .. inputPlaybackLines)
    inputPlaybackLines = 0
    inputPlaybackCommLines = 0

    if inputBreakpointIsActive < 2 then return end

    if inputBreakpointIsActive == 2 then
        --debug_removeBreakpoint(varInputBreak)
        inputBreakpointIsActive = 0

        debug_continueFromBreakpoint(co_run)
    else -- inputBreakpointIsActive = 3
        inputBreakpointIsActive = 1
	end
    --remember to undo fast forward
    fftoggle = 0
end

--saves filename and sets up recording
--TODO: only open file when player agrees to save it.
function StartRecording()
    if ReattachFP(0) == 0 then return end
    if inputBreakpointIsActive ~= 0 and inputBreakpointIsActive ~= 4 then return end

    --asks for file
    if isempty(recordingFile) then
        load_dialog = createOpenDialog(self)
        load_dialog.InitalDir = ftrainerDirectory
        load_dialog.Title = "Open Playback File"
        load_dialog.execute()
        recordingFile = load_dialog.FileName
    end
    if isempty(recordingFile) then
        return end
    local f = io.open(recordingFile,"w")
    if isempty(f) then
        showMessage("Could not start recording file")
        return
    else f:close() end


    --writes playback header
    recordingText = "playback\n"

    local t = getProperty(FTrainerMain.CEComboBox3,"ItemIndex")
    recordingText = recordingText .. "character " .. tostring(customCharacter) .. "\n"

    if t > 0 then
        if t > 1 then
          recordingText = recordingText .. "warp " .. t-1 .. "\n"
        else
           recordingText = recordingText .. "warp custom " .. tostring(customFrame) .. " " .. tostring(Round3(customCheckX)) .. " " .. tostring(Round3(customCheckY)) .. "\n"
        end
        if customShield ~= 0 then
            recordingText = recordingText .. "shield " .. tostring(math.floor(customShield)) .. " " .. tostring(math.floor(customShieldHP + 1)) .. "\n"
        end
        if customLock == 0 then
          recordingText = recordingText .. "unlock\n" end

        recordingText = recordingText .. "seed " .. getProperty(FTrainerMain.BTASSeed,"Text") .. "\n"

        if customHealth ~= 14 then
            recordingText = recordingText .. "health " .. tostring(customHealth) .. "\n" end
        if t == 1 then
            recordingText = recordingText .. "meter " .. tostring(customMeter) .. "\n"
            recordingText = recordingText .. "globalcycle " .. tostring(customCycle) .. "\n"
        end
    end

    inputPlaybackLines = 0
    recordingText = recordingText .. "inputs\n"
    inputBreakpointIsActive = -2
    setProperty(FTrainerMain.CEButton17,"Hint",recordingFile)
    setProperty(FTrainerMain.ToolStatus,"Caption","Starting Recording")
end


--Same as above, but resetting the saved filename
function StartRecordingAlt()
    local h = recordingFile
    recordingFile = nil
    setProperty(FTrainerMain.CEButton17,"Hint",nil)
    StartRecording()
    if recordingFile == nil then
        recordingFile = h
        setProperty(FTrainerMain.CEButton17,"Hint",h)
    end
end


--Runs every time the breakpoint is hit.
--does different things depending on the value of inputBreakpointIsActive
--and pause/fastforward flags.
function debugger_onBreakpoint()
    --if state is 100,
    --checks if the playback is being done from start
    if inputBreakpointIsActive == 100 then
        debug_setBreakpoint(varInputBreak)
        inputBreakpointIsActive = 2
        return 1
    end
    --triggers during fastforward breakpoint and skips rendering.
    if EIP == getAddress("FP.exe")+ 0x1877C9 then
        if has_value({1,3,5},inputBreakpointIsActive) and frameadvancetrigger == 0 then
            EIP = getAddress("FP.exe") + 0x1877FB
        end
        --here you check if
        --1. the new toggle is active. just make a
        return 1
    end
    if EIP == getAddress("FP.exe") + 0x188065 then
        if fftoggle > 0 then
            --EIP = getAddress("FP.exe") + 0x1877D0
            EIP = getAddress("FP.exe") + 0x188028
        end
        return 1
    end

    --if game pause toggle is on, forces game to skip processing actions.
    --game pause trigger
    if gamePauseTrigger then
        gamePauseTrigger = false
        GamePause()
    end

    --if frame advance toggle is on call frameadvance and reset toggle.
    if frameadvancetrigger == 1 then
        frameAdvance()
        frameadvancetrigger = 0
        return 1
    end

    --testing stuff
    --if EIP == getAddress("FP.exe") + 0x26b6f2 then
    --   setProperty(FTrainerMain.CustomStatus,"Caption",EAX)
    --   return 0
    --end
    --if breakpointTestToggle and EIP == getAddress("FP.exe")+ breakpointTestAddressValue then
        --return BreakpointTestCount()
    --end

    --pauses for any breakpoint that's not the main one (for other testing)
    --if inputBreakpointIsActive == 2 then print(varInputBreakValue) end
    -- here you have to update lastObjectHit if the address is in hitBreakPoints

    --if instruction of breakpoint was a hit detection (for display and object),
    --calls function to detect object hit
    if not isempty(hitBreakPointsIndex[tostring(EIP)]) then
        checkHitBreakpoint(EIP,EAX,ECX,EDI)
        return 1
    end

    --if instruction of breakpoint was anything else,
    --it is either an RNG counter update or regular debugging BP
    if EIP ~= getAddress("FP.exe") +  varInputBreakValue then
        return updateRNGCounter(EIP - getAddress("FP.exe"))
    end

    --if warp was called from frame 0, executes temporary warp to main menu.
    if inputBreakpointIsActive < -2 then
        inputBreakpointIsActive = inputBreakpointIsActive + 10
        if inputBreakpointIsActive <-2 then
            return 1
        else
            if inputBreakpointIsActive == -1 then
                playbackInputs()
            else if inputBreakpointIsActive == -2 then
                --something
            else
                hFunc[postWarpCode].onHotkey()
            end end
            return 1
        end
    end

    --state is over 8: post warp attributions must be applied.
    --Applies second part of specific warps if necessary
    if inputBreakpointIsActive >= 9 then
        inputBreakpointIsActive = inputBreakpointIsActive - 10
        applyPostWarp()
    end

    --state is -1 or -2: a trainer warp is about to trigger.
    --finishes the transition to start playback or recording
    if inputBreakpointIsActive == -1 or inputBreakpointIsActive == -2 then
        if getProperty(FTrainerMain.CEComboBox3,"ItemIndex") > 0 then
            local playbackWarp = choosePlaybackWarp(getProperty(FTrainerMain.CEComboBox3,"ItemIndex"))
            if playbackWarp == 1 then
                HotkeyWarp1()
            end
            if playbackWarp == 2 then
                HotkeyWarp2()
            end
            if playbackWarp == 3 then
                HotkeyWarp3()
            end
            if playbackWarp == 4 then
                HotkeyWarp4()
            end
            if playbackWarp == 5 then
                HotkeyWarp5()
            end
            if playbackWarp == 6 then
                HotkeyWarp6()
            end
            if playbackWarp == 7 then
                HotkeyWarp7()
            end
            if playbackWarp == 8 then
                HotkeyWarp8()
            end
            if playbackWarp == 9 then
                HotkeyWarp9()
            end
            if playbackWarp == 10 then
                HotkeyWarp10()
            end
            if playbackWarp == 11 then
                HotkeyWarp11()
            end
            if playbackWarp == 12 then
                HotkeyWarp12()
            end
            if playbackWarp == 13 then
                HotkeyWarp13()
            end
            if playbackWarp == 14 then
                HotkeyWarp14()
            end
            if playbackWarp == 15 then
                WarpCustom()
            end
        end
        --TODO: describe what 13 and 16 means, PLEASE
        --added 10 to the values because of the postwarp
        if inputBreakpointIsActive % 10 == 9 then
            inputBreakpointIsActive = inputBreakpointIsActive + 13
        else inputBreakpointIsActive = inputBreakpointIsActive + 16 end
        return 1
    end

    -- functions that apply to all remaining breakpoint states (-2 to 5)

    --Applies misc settings
    --timerlock locks the in-game timer to 10 minutes.
    if miscTimerLock  then writeDouble(varIgt,600000) end

    --livesdisplay hides live count display, to make crystals display more visible.
    if miscLivesDisplay then
        writeInteger(varLivesDisplay,300)
        writeInteger(varLivesDisplay2,300)
    end

    --Applies crystal display settings
    --crystalPos controls the position on the screen to place the crystal display.
    if miscCrystalPos then
        writeInteger(varCrystalPosX,miscCrystalPosX)
        writeInteger(varCrystalPosY,miscCrystalPosY)
    end

    --TODO: proper description
    if miscSpeedScreen then
        writeInteger(varCrystalDisplay,miscSpeedScreenDisplay2)
        writeInteger(varCrystalDisplay2,miscSpeedScreenDisplay1)
    end

    --applies timer stop settings
    if miscTimerStop then
        if miscTimerStopTrigger then
            writeDouble(varIgt,miscTimerTriggerValue)
        else
            if miscTimerFrame or miscTimerPosX or miscTimerFlag then
                local x = true
                if miscTimerFrame then
                    if readInteger(varFrame)~= valTimerFrame then
                        x = false
                    end
                end
                if miscTimerPosX then
                    local v = readDouble(varTrueX)
                    if isempty (v) then x = false
                    else if v < valTimerPosX then
                        x = false
                end end
            end
            if miscTimerFlag then
                if readDouble(varCheckFlag) < valTimerFlag then
                    x = false
                end
            end
            --if all conditions were met, stop timer
            if x then
                miscTimerStopTrigger = true
                miscTimerTriggerValue = readDouble(varIgt)
                -- check first if time was actually beaten
                if miscTimerPB and miscTimerTriggerValue < valTimerLimit + 600000 then
                    valTimerLimit = miscTimerTriggerValue  - 600000
                    local tt1 = math.floor(valTimerLimit / 1000)
                    local tt2 = math.floor((valTimerLimit % 1000) / 10)
                    setProperty(FTrainerTimer.CEEdit5,"Text",tostring(tt1) .. "." .. tostring(tt2))
                end
            else
            --if not yet, check it timer limit was hit and apply the punishment
                if miscTimerLimit and miscTimerLimitTrigger == false then
                    if readDouble(varIgt) >= valTimerLimit + 600000 then
                     --actually apply punishment
                        miscTimerLimitTrigger = true
                        TriggerExplode()
                    end
                end
            end
        end end
    end

    --movement speed boost increase
    --TODO: group all misc settings together, if that doesn't break anything.
    --TODO: again, please explain what all these values are
    if miscMovement then
        local mult = readDouble(varCrystalCount) + (4 * readDouble(varOrbCount))
        mult = 1 + (mult / 200)
        --writeDouble(0x2b61250,5 * mult)
        --local addr = getAddress(varSpeedX) - 0xf8
        local addr = readInteger(varAVs)
        if not isempty(addr) then
            local addr2 = addr + 0x100
            if readDouble(addr2) ~=0 then
                writeDouble(addr2,5 * mult)
            end
            addr2 = addr+0x108
            writeDouble(addr2,15 * mult)
            --end
            addr2 = addr+0x110
            if readDouble(addr2) ~=0 then
                writeDouble(addr2,0.07375 * mult)
            end
            addr2 = addr+0x118
            if readDouble(addr2) ~=0 then
                writeDouble(addr2,0.203125 * mult)
            end
            addr2 = addr+0x128
            if readDouble(addr2) ~=0 then
                writeDouble(addr2,15 * mult)
            end
            addr2 = addr+0x130
            if readDouble(addr2) ~=0 then
                writeDouble(addr2,0.25 * mult)
            end
            addr2 = addr+0x138
            if readDouble(addr2) ~=0 then
                writeDouble(addr2,0.84 * mult)
            end
            if readDouble(varJump) ~=0 then
                writeDouble(varJump,(-7) * mult)
               --writeDouble(varJump2,5 * mult)
            end
        end
    end

    --flag is 0: no playback or recording state.
    if inputBreakpointIsActive == 0 then
    --synchronize hotkey warps
    --calling the requested warp function during breakpoint makes them
    --much more reliable.
    --TODO: find a way to use the equivalent of function pointers instead!
        if HotkeyWarpToggle ~= 0 then
            local warp = HotkeyWarpToggle
            HotkeyWarpToggle = 0
            if warp == 1 then
                HotkeyWarp1()
            end
            if warp == 2 then
                HotkeyWarp2()
            end
            if warp == 3 then
                HotkeyWarp3()
            end
            if warp == 4 then
                HotkeyWarp4()
            end
            if warp == 5 then
                HotkeyWarp5()
            end
            if warp == 6 then
                HotkeyWarp6()
            end
            if warp == 7 then
                HotkeyWarp7()
            end
            if warp == 8 then
                HotkeyWarp8()
            end
            if warp == 9 then
                HotkeyWarp9()
            end
            if warp == 10 then
                HotkeyWarp10()
            end
            if warp == 11 then
                HotkeyWarp11()
            end
            if warp == 12 then
                HotkeyWarp12()
            end
            if warp == 13 then
                HotkeyWarp13()
            end
            if warp == 14 then
                HotkeyWarp14()
            end
            if warp == 15 then
                WarpCustom()
            end
            --switches to postwarp settings state
            inputBreakpointIsActive = inputBreakpointIsActive + 10
            return 1
        end

        --apply automatic inputs if the option has been toggled
        applyTInputs()

        --increments playback frame counter
        if inputPlaybackLines > 0 then
            inputPlaybackLines = inputPlaybackLines + 1

            -- if there are commentary lines, shows both comment and playback line count.
            if inputPlaybackCommLines == 0 then
                setProperty(FTrainerMain.ToolStatus,"Caption", "Advanced to frame ".. inputPlaybackLines)
            else
                setProperty(FTrainerMain.ToolStatus,"Caption", "Advanced to frame ".. inputPlaybackLines .. " (" .. inputPlaybackLines + inputPlaybackCommLines .. ")")
            end
        end

        --special item block
        if specialItemBlock ~= 0 then
           if specialItemBlock == 2 then
              specialItemBlock = 1
              writeDouble(varState,30)
           else
               specialItemBlock = 0
               writeDouble(varBlock,1)

           end
        end
        --activates randomly exploding if the option has been selected
        if miscExplode then
            if math.random(1,RandomExplodeRate) == 1 and readInteger(varPaused) % 256 == 1 then
                TriggerExplode()
           end
        end
        --activates instant death if the option has been selected
        --and conditions met.
        if miscInstantDeath then
            writeDouble(varExplode,1)
            writeInteger(varHealthBar,1)
        end
        --activates limited lives if the option has been selected.
        if miscLimitedLives then
            if readInteger(varLives) > 4 then
                writeInteger(varLives,4)
            end
        else
            --locks lives count to 150 otherwise. for visual cheat detection.
            --TODO: make more detailed conditions
            writeInteger(varLives,150)
        end
        --activates limited invincibility if the option has been selected.
        if miscInvincibility then
            --TODO: look for a min function to make this process more readable.
            if readDouble(varInvincibility) > 8 then
                writeDouble(varInvincibility,8)
            end
        end
        --activates infinite keycards, if the option has been selected.
        if miscKeycard then
            writeDouble(varKeyCard,9)
        end
        return 1
    end

    --breakpoint state is over 9: post warp settings, so just skip.
    if inputBreakpointIsActive >= 9 then return 1 end

    --breakpoint state is 4: currently recording inputs.
    --in this case, write next line to file.
    --either from game inputs or virtual controller inputs.
    --TODO: check if state 5 should have been included here
    if inputBreakpointIsActive == 4 then
        if readInputsFromDisplay then
            applyTInputs()
            recordingText = recordingText .. applyRInputs()
        else
            recordingText = recordingText .. PlaybackInputRecord()
        end
        return 1
    end

    --breakpoint state is 2 or 3: currently doing a playback
    if inputBreakpointIsActive ~= 2 and inputBreakpointIsActive ~= 3 then
        if getProperty(FTrainerDataview,"Visible") then UpdateAdvancedDataview() end
        return 1
    end

    --remaining breakpoint states are 2 and 3
    --if playback is about to end and set to pause at the end, pause at the end.
    if inputPlaybackPauseFrame == inputPlaybackLines + inputPlaybackCommLines +1 and inputPlaybackPauseFrame > 0 then
        GamePause()
        if getProperty(FTrainerDataview,"Visible") then UpdateAdvancedDataview() end
        fftoggle = 0
    end

    --read inputs for playback, as the remaining states are playback states.
    playbackInputRead()
    return 1
end

--Applies some warp changes that must happen after the warp is done
function applyPostWarp()
    --applies initial RNG value, if it is a valid number.
    --TODO: check if value is a valid unsigned int
    if getProperty(FTrainerMain.CECheckbox6,"Checked") then
        dataFirstSeed = tonumber(getProperty(FTrainerMain.BTASSeed,"Text"))
        if not isempty(dataFirstSeed) then writeInteger(varBossSeed,dataFirstSeed) end
    else
        dataFirstSeed = readInteger(varBossSeed)
        setProperty(FTrainerMain.BTASSeed,"Text",dataFirstSeed)
    end

    --exit if there's no post warp operation to be done.
    if not has_value({6,8,9,10,12,13,15},postWarpCode) then
        return
    end
    --if input unlock is not enabled for custom warp, also exit
    if postWarpCode == 15 and customLock == 1 then
        return
    end
    --skips intro fadein
    writeDouble(varFadein,136)
    --forces input unlock
    writeDouble(varInputLock, 0)
    --not sure if removing the line below will cause desynchs
    --these two paused attributions force the game pause upon warp to end early
    --writeInteger(varPaused,1)
    writeInteger(varPausedB,1)

    --for FD1 boss, forces the character to start at max speed
    if postWarpCode == 8 then
        writeDouble(varSpeedX,15)
    end

    --for FD2 boss, forces quick fall into position close to the boss
    if postWarpCode == 10 then
        writeDouble(varTrueX,7400)
        writeDouble(varTrueY,4850)
        writeDouble(varSpeedY,15)
    end

    --For FD4 boss first phase, places the player into the elevator.
    if postWarpCode == 12 then
    --if readInteger(varFrame) == 72 and readDouble(varCheckFlag) < 2 then
        writeDouble(varTrueX,2550)
    end

    --for dreadbox, sets the box's drop to be an explosion instead of crystals
    if (customFrame == 67 or postWarpCode == 9) then
        writeDouble(varBoxExplode,9)
    end

    --for TB 5th screen, forces water level back to starting point
    if customFrame == 48 then writeDouble(varWater,2920) end

    --applies custom warp speed, if the option has been selected
    if customSpeedToggle then
        writeDouble(varSpeedX,customSpeedX)
        writeDouble(varSpeedY,customSpeedY)
    end

    --applies the respective character's special item, if the option has been selected.
    if customSpecialToggle then
        SpecialItem()
    end
end

--Read a line of the file to apply inputs
function playbackInputRead()
    local headerLine = {}
    local fileLineSplit = {}
    --loop keeps going until a line without commentary (0,1 or empty) is found
    while true do
        if not inputPlaybackFile then return 1 end
        fileLineSplit = inputPlaybackFile:read("*line")
        local header = {}
        if isempty(fileLineSplit) then break end
        for word in string.gmatch(fileLineSplit, "[%w%p]+") do
            headerLine[#headerLine+1] = word
        end

        --forced speed change into inputs
        --remember to add fail conditions later
        if headerLine[1] == "speed" and tonumber(headerLine[2]) then
            --inputPlaybackCommLines = inputPlaybackCommLines + 1
            headerLine[2] = tonumber(headerLine[2])
            setProperty(FTrainerMain.CEComboBox2,"ItemIndex",headerLine[2]-1)
            CEComboBox2Change()
        end

     --forced pause into inputs
        if headerLine[1] == "pause" and inputBreakpointIsActive == 2 then
            inputPlaybackCommLines = inputPlaybackCommLines + 1
            GamePause()
            fftoggle = 0
        end

        --commentary stuff
        if headerLine[1] ~= '0' and headerLine[1] ~= '1' and headerLine[1] ~= "." then
            inputPlaybackCommLines = inputPlaybackCommLines + 1
        else
            break
        end
    end
    --Checks for playback file EOF
    if #headerLine ~= 8 or headerLine[1] == "end" then
        playbackFromStart = false
        fftoggle = 0
        if inputBreakpointIsActive == 3 then --when playback ends while the game is paused
            inputBreakpointIsActive = 1
       --setProperty(FTrainerMain.ToolStatus,"Caption","Finished reading " .. inputPlaybackLines .. " (" .. inputPlaybackLines  + inputPlaybackCommLines .. ") lines.")
            applyTInputs()
            inputPlaybackFile:close()
            return 1
        end
        if getProperty(FTrainerMain.CECheckbox4,"Checked") and inputPlaybackPauseFrame == 0 then --when pausing automatically after playback
            setProperty(FTrainerMain.TPauseButton,"Caption","Unpause")
            setProperty(FTrainerMain.ToolStatus,"Caption","Finished reading " .. inputPlaybackLines .. " (" .. inputPlaybackLines  + inputPlaybackCommLines .. ") lines.")
            inputBreakpointIsActive = 1
            if not getProperty(FTrainerMain.CECheckbox7,"Checked") then
                inputPlaybackLines = 0
            else inputPlaybackLines = inputPlaybacklines + 1
            end
            ChangeInputButtons(lastPlaybackInput[1],lastPlaybackInput[2],lastPlaybackInput[3],lastPlaybackInput[4],lastPlaybackInput[5],lastPlaybackInput[6],lastPlaybackInput[7],lastPlaybackInput[8])
            applyTInputs()
            inputPlaybackFile:close()
            return 1
        else --when pausing after playback is not checked
            inputBreakpointIsActive = 0
            setProperty(FTrainerMain.ToolStatus,"Caption","Finished reading " .. inputPlaybackLines .. " (" .. inputPlaybackLines  + inputPlaybackCommLines .. ") lines.")
            if not getProperty(FTrainerMain.CECheckbox7,"Checked") then
                inputPlaybackLines = 0
            end
            inputPlaybackFile:close()
            return 1
        end
    end

    --Applies inputs from file line
    if headerLine[1]=='1' then
        writeDouble(varInputUp,1000)
    else writeDouble(varInputUp,0)
    end
    if headerLine[2]=='1' then
        writeDouble(varInputDown,1000)
    else writeDouble(varInputDown,0)
    end
    if headerLine[3]=='1' then
        writeDouble(varInputLeft,1000)
    else writeDouble(varInputLeft,0)
    end
    if headerLine[4]=='1' then
        writeDouble(varInputRight,1000)
    else writeDouble(varInputRight,0)
    end
    if headerLine[5]=='1' then
        writeDouble(varInputJump,1000)
        else writeDouble(varInputJump,0)
    end
        if headerLine[6]=='1' then
            writeDouble(varInputAttack,1000)
        else writeDouble(varInputAttack,0)
    end
        if headerLine[7]=='1' then
            writeDouble(varInputSpecial,1000)
        else writeDouble(varInputSpecial,0)
    end
    if headerLine[8]=='1' then
        writeDouble(varInputPause,1000)
    else writeDouble(varInputPause,0)
    end
    --Updates needed counters
    inputPlaybackLines = inputPlaybackLines + 1
    --TODO: make the entry paramater an array for much better readability
    lastPlaybackInput = {headerLine[1],headerLine[2],headerLine[3],headerLine[4],headerLine[5],headerLine[6],headerLine[7],headerLine[8]}

    if fftoggle == 0 then
        if inputBreakpointIsActive == 2 then
            if inputPlaybackCommLines == 0 then
                setProperty(FTrainerMain.ToolStatus,"Caption","Playing frame ".. inputPlaybackLines)
            else
                setProperty(FTrainerMain.ToolStatus,"Caption","Playing frame ".. inputPlaybackLines .. " (" .. inputPlaybackLines + inputPlaybackCommLines .. ")")
            end
        end
        if inputBreakpointIsActive == 3 --[[or inputPlaybackPauseFrame == inputPlaybackLines]] then
            --TODO: make the entry paramater an array for much better readability
            ChangeInputButtons(headerLine[1],headerLine[2],headerLine[3],headerLine[4],headerLine[5],headerLine[6],headerLine[7],headerLine[8])
            if inputPlaybackCommLines == 0 then
                setProperty(FTrainerMain.ToolStatus,"Caption","Paused at frame ".. inputPlaybackLines)
            else
                setProperty(FTrainerMain.ToolStatus,"Caption","Paused at frame ".. inputPlaybackLines .. " (" .. inputPlaybackLines + inputPlaybackCommLines .. ")")
            end
        end
    end
    return 1
end

--look at currently pressed inputs and
function PlaybackInputRecord()

    inputLine = ""

    if readDouble(varInputUp) == 1000 then
        inputLine = "1 "
    else inputLine = ". " end
    if readDouble(varInputDown) == 1000 then
        inputLine = inputLine .. "1 "
    else inputLine = inputLine .. ". " end
    if readDouble(varInputLeft) == 1000 then
        inputLine = inputLine .. "1 "
    else inputLine = inputLine .. ". " end
    if readDouble(varInputRight) == 1000 then
        inputLine = inputLine .. "1 "
    else inputLine = inputLine .. ". " end
    if readDouble(varInputJump) == 1000 then
        inputLine = inputLine .. "1 "
    else inputLine = inputLine .. ". " end
    if readDouble(varInputAttack) == 1000 then
        inputLine = inputLine .. "1 "
    else inputLine = inputLine .. ". " end
    if readDouble(varInputSpecial) == 1000 then
        inputLine = inputLine .. "1 "
    else inputLine = inputLine .. ". " end
    if readDouble(varInputPause) == 1000 then
        inputLine = inputLine .. "1\n"
    else inputLine = inputLine .. ".\n" end

    inputPlaybackLines = inputPlaybackLines + 1
    setProperty(FTrainerMain.ToolStatus,"Caption","Recording Frame " .. inputPlaybackLines)

    return inputLine
end

--applyTInputs, but for recording
function applyRInputs()
    if not readInputsFromDisplay then return "" end

    inputLine = ""
    if getProperty(FTrainerMain.TButtonUp,"Checked") then
        inputLine = "1 "
    else inputLine = ". " end
    if getProperty(FTrainerMain.TButtonDown,"Checked") then
        inputLine = inputLine .. "1 "
    else inputLine = inputLine .. ". " end
    if getProperty(FTrainerMain.TButtonLeft,"Checked") then
        inputLine = inputLine .. "1 "
    else inputLine = inputLine .. ". " end
    if getProperty(FTrainerMain.TButtonRight,"Checked") then
        inputLine = inputLine .. "1 "
    else inputLine = inputLine .. ". " end
    if getProperty(FTrainerMain.TButtonA,"Checked") then
        inputLine = inputLine .. "1 "
    else inputLine = inputLine .. ". " end
    if getProperty(FTrainerMain.TButtonB,"Checked") then
        inputLine = inputLine .. "1 "
    else inputLine = inputLine .. ". " end
    if getProperty(FTrainerMain.TButtonC,"Checked") then
        inputLine = inputLine .. "1 "
    else inputLine = inputLine .. ". " end
    if getProperty(FTrainerMain.TButtonP,"Checked") then
        inputLine = inputLine .. "1\n"
    else inputLine = inputLine .. ".\n" end

    return inputLine
end

--Updates the inputs display
function ChangeInputButtons(i1,i2,i3,i4,i5,i6,i7,i8)
    if i1 == '1' then
        setProperty(FTrainerMain.TButtonUp,"Checked",true)
    else setProperty(FTrainerMain.TButtonUp,"Checked",false)
    end
    if i2 == '1' then
        setProperty(FTrainerMain.TButtonDown,"Checked",true)
    else setProperty(FTrainerMain.TButtonDown,"Checked",false)
    end
    if i3 == '1' then
        setProperty(FTrainerMain.TButtonLeft,"Checked",true)
    else setProperty(FTrainerMain.TButtonLeft,"Checked",false)
    end
    if i4 == '1' then
        setProperty(FTrainerMain.TButtonRight,"Checked",true)
    else setProperty(FTrainerMain.TButtonRight,"Checked",false)
    end
    if i5 == '1' then
        setProperty(FTrainerMain.TButtonA,"Checked",true)
    else setProperty(FTrainerMain.TButtonA,"Checked",false)
    end
    if i6 == '1' then
        setProperty(FTrainerMain.TButtonB,"Checked",true)
    else setProperty(FTrainerMain.TButtonB,"Checked",false)
    end
    if i7 == '1' then
        setProperty(FTrainerMain.TButtonC,"Checked",true)
    else setProperty(FTrainerMain.TButtonC,"Checked",false)
    end
    if i8 == '1' then
        setProperty(FTrainerMain.TButtonP,"Checked",true)
    else setProperty(FTrainerMain.TButtonP,"Checked",false)
    end
end

--Hotkeys to call functions based on key presses
hFunc = {}
hFunc[1] = createHotkey(HotkeyWarpToggle1, HotkeyValueDefault[1])
hFunc[2] = createHotkey(HotkeyWarpToggle2, HotkeyValueDefault[2])
hFunc[3] = createHotkey(HotkeyWarpToggle3, HotkeyValueDefault[3])
hFunc[4] = createHotkey(HotkeyWarpToggle4, HotkeyValueDefault[4])
hFunc[5] = createHotkey(HotkeyWarpToggle5, HotkeyValueDefault[5])
hFunc[6] = createHotkey(HotkeyWarpToggle6, HotkeyValueDefault[6])
hFunc[7] = createHotkey(HotkeyWarpToggle7, HotkeyValueDefault[7])
hFunc[8] = createHotkey(HotkeyWarpToggle8, HotkeyValueDefault[8])
hFunc[9] = createHotkey(HotkeyWarpToggle9, HotkeyValueDefault[9])
hFunc[10] = createHotkey(HotkeyWarpToggle10, HotkeyValueDefault[10])
hFunc[11] = createHotkey(HotkeyWarpToggle11, HotkeyValueDefault[11])
hFunc[12] = createHotkey(HotkeyWarpToggle12, HotkeyValueDefault[12])
hFunc[13] = createHotkey(HotkeyWarpToggle13, HotkeyValueDefault[13])
hFunc[14] = createHotkey(HotkeyWarpToggle14, HotkeyValueDefault[14])
hFunc[15] = createHotkey(HotkeyWarpToggle15, HotkeyValueDefault[15])
hFunc[16] = createHotkey(LastUsedWarp, HotkeyValueDefault[16])
hFunc[17] = createHotkey(RefillStats, HotkeyValueDefault[17])
hFunc[18] = createHotkey(SpeedBoost, HotkeyValueDefault[18])
hFunc[19] = createHotkey(SpecialItem, HotkeyValueDefault[19])
hFunc[20] = createHotkey(InstantMove, HotkeyValueDefault[20])
hFunc[21] = createHotkey(InputUnlock, HotkeyValueDefault[21])
hFunc[22] = createHotkey(ExplodeForNoReason,HotkeyValueDefault[22])
hFunc[23] = createHotkey(playbackInputs, HotkeyValueDefault[23])
hFunc[24] = createHotkey(GamePause, HotkeyValueDefault[24])
hFunc[25] = createHotkey(FrameAdvanceTrigger, HotkeyValueDefault[25])
hFunc[26] = createHotkey(playbackStop, HotkeyValueDefault[26])
hFunc[27] = createHotkey(ChangeGameSpeedUp, HotkeyValueDefault[27])
hFunc[28] = createHotkey(ChangeGameSpeedDown, HotkeyValueDefault[28])
hFunc[29] = createHotkey(StartRecording, HotkeyValueDefault[29])
for h = 1,#hFunc do setProperty(hFunc[h],"DelayBetweenActivate",500) end
setProperty(hFunc[18],"DelayBetweenActivate",200)
setProperty(hFunc[21],"DelayBetweenActivate",600)
setProperty(hFunc[22],"DelayBetweenActivate",200)
setProperty(hFunc[23],"DelayBetweenActivate",600)
setProperty(hFunc[24],"DelayBetweenActivate",400)
setProperty(hFunc[25],"DelayBetweenActivate",300)
setProperty(hFunc[26],"DelayBetweenActivate",600)
setProperty(hFunc[29],"DelayBetweenActivate",600)
--setProperty(hFunc[27],"DelayBetweenActivate",500)
--setProperty(hFunc[28],"DelayBetweenActivate",500)

--treats file drag according to current tab
--change this to treat according to 1st line of file
function TrainerDragFiles(sender,files)
    f = io.open(files[1])
    local t = f:read("*line")
    if t == "playback" then
        playbackFileName = files[1]
        playbackInputs()
        setProperty(FTrainerMain.CEPageControl1,"TabIndex",7)
    end
    if t == "commands" then
        readKeys(sender,files[1])
        setProperty(FTrainerMain.CEPageControl1,"TabIndex",6)
    end
    if t == "customwarp" then
        ReadCustomWarp(sender,files[1])
        setProperty(FTrainerMain.CEPageControl1,"TabIndex",2)
    end
end

--ADVANCED DATAVIEW STUFF
dataPlayback = 0
dataFrame = 0
dataCycle = 0
dataPosX = 0
dataPosY = 0
dataSpeedX = 0
dataSpeedY = 0
dataGrounded = 0
dataAngle = 0
dataHealth = 0
dataMeter = 0
dataSeed = 0
dataFirstSeed = 0


function CEButton12Click()
    FTrainerDataview.show()
    UpdateAdvancedDataview()
end

function CEButton13Click()
    FTrainerDataview.show()
    setProperty(FTrainerDataview.CECheckbox1,"Checked",true)
    UpdateAdvancedDataview()
end

function CEButton19Click()
    FTrainerObject.show()
    setProperty(FTrainerObject.CECheckbox1,"Checked",true)
    UpdateObjectDataview()
end

--Updates all texts on advanced dataview
function UpdateAdvancedDataview()
    if ReattachFP(0) == 0 then return end
     --Fetches all values

    dataPlayback = inputPlaybackLines
    dataFrame = readInteger(varFrame)
    dataCheckFlag = readDouble(varCheckFlag)
    dataCycle = readDouble(varGlobalCycle)
    dataPosX = readDouble(varTrueX)
    dataPosY = readDouble(varTrueY)
    dataSpeedX = readDouble(varSpeedX)
    dataSpeedY = readDouble(varSpeedY)
    dataState = readDouble(varState)
    dataGrounded = readDouble(varGrounded)
    dataAngle = readDouble(varAngle)
    dataHealth = readDouble(varHealth)
    dataMeter = readDouble(varMeter)
    dataSeed = readInteger(varBossSeed)
     --nothing to dataFirstSeed, of course
     --writes values to labels

    if inputPlaybackLines > 0 then
        if inputPlaybackCommLines == 0 then
            setProperty(FTrainerDataview.CELabel1,"Caption", "Playback frame: " .. dataPlayback)
        else
            setProperty(FTrainerDataview.CELabel1,"Caption", "Playback frame: " .. dataPlayback .. " (" .. dataPlayback + inputPlaybackCommLines .. ")")
        end
        setProperty(FTrainerDataview.CELabel1,"Visible", true)
    else
        setProperty(FTrainerDataview.CELabel1,"Visible", false)
    end
    if not isempty(dataFrame) then
        setProperty(FTrainerDataview.CELabel2,"Caption","Screen ID: " .. dataFrame .. " (" .. math.floor(dataCheckFlag) .. ")")
        setProperty(FTrainerDataview.CELabel2,"Visible",true)
    else setProperty(FTrainerDataview.CELabel2,"Visible",false) end
    if not isempty(dataCycle) then
        setProperty(FTrainerDataview.CELabel3,"Visible",true)
        setProperty(FTrainerDataview.CELabel3,"Caption","Global Cycle: " .. math.floor(dataCycle))
    else setProperty(FTrainerDataview.CELabel3,"Visible",false) end
    if not isempty(dataPosX) then
        setProperty(FTrainerDataview.CELabel4,"Caption","Position X: " .. Round3(dataPosX))
        setProperty(FTrainerDataview.CELabel4,"Visible",true)
    else setProperty(FTrainerDataview.CELabel4,"Visible",false) end
    if not isempty(dataPosY) then
        setProperty(FTrainerDataview.CELabel5,"Caption","Position Y: " .. Round3(dataPosY))
        setProperty(FTrainerDataview.CELabel5,"Visible",true)
    else setProperty(FTrainerDataview.CELabel5,"Visible",false) end
    if not isempty(dataSpeedX) then
        setProperty(FTrainerDataview.CELabel6,"Caption","Speed X: " .. Round4(dataSpeedX))
        setProperty(FTrainerDataview.CELabel6,"Visible",true)
        if(dataSpeedX>=15 or dataSpeedX<=-15) then
            FTrainerDataview.CELabel6.Font.Color = 0x0000ff
        else FTrainerDataview.CELabel6.Font.Color = 0x000000 end
    else setProperty(FTrainerDataview.CELabel6,"Visible",false) end
    if not isempty(dataSpeedY) then
        if dataSpeedY == 0 then setProperty(FTrainerDataview.CELabel7,"Caption","Speed Y: 0.0")
        else setProperty(FTrainerDataview.CELabel7,"Caption","Speed Y: " .. (-1) * Round4(dataSpeedY)) end
        setProperty(FTrainerDataview.CELabel7,"Visible",true)
        if(dataSpeedY>=15 or dataSpeedY<=-15) then
               FTrainerDataview.CELabel7.Font.Color = 0x0000ff
        else if (dataSpeedY>-4 and dataSpeedY < 0) then
               FTrainerDataview.CELabel7.Font.Color = 0xff0000
        else FTrainerDataview.CELabel7.Font.Color = 0x000000 end
    end
    else setProperty(FTrainerDataview.CELabel7,"Visible",false) end
    if not isempty(dataState) then
        setProperty(FTrainerDataview.CELabel8,"Caption","State: " .. math.floor(dataState))
        setProperty(FTrainerDataview.CELabel8,"Visible",true)
    else setProperty(FTrainerDataview.CELabel8,"Visible",false) end
    if not isempty(dataGrounded) then
        if dataGrounded == 1 then
           setProperty(FTrainerDataview.CELabel9,"Caption","Grounded: yes")
        else
            setProperty(FTrainerDataview.CELabel9,"Caption","Grounded: no")
        end
        setProperty(FTrainerDataview.CELabel9,"Visible",true)
    else setProperty(FTrainerDataview.CELabel9,"Visible",false) end
    if not isempty(dataAngle) then
        setProperty(FTrainerDataview.CELabel10,"Caption","Angle: " .. Round1(dataAngle))
        setProperty(FTrainerDataview.CELabel10,"Visible",true)
    else setProperty(FTrainerDataview.CELabel10,"Visible",false) end
    if not isempty(dataHealth) then
        setProperty(FTrainerDataview.CELabel11,"Caption","Health: " .. dataHealth)
        if readDouble(varShield) ~= 0 then setProperty(FTrainerDataview.CELabel11,"Caption",getProperty(FTrainerDataview.CELabel11,"Caption") .. " (+" .. math.floor(readDouble(varShieldHP)+1) .. ")") end
        setProperty(FTrainerDataview.CELabel11,"Visible",true)
    else setProperty(FTrainerDataview.CELabel11,"Visible",false) end
    if not isempty(dataMeter) then
        setProperty(FTrainerDataview.CELabel12,"Caption","Meter: " .. dataMeter)
        setProperty(FTrainerDataview.CELabel12,"Visible",true)
    else setProperty(FTrainerDataview.CELabel12,"Visible",false) end
    if not isempty(dataSeed) and FPVersion ~= 1 then
        setProperty(FTrainerDataview.CELabel13,"Caption","RNG value: " .. dataSeed)
        setProperty(FTrainerDataview.CELabel13,"Visible",true)
    else setProperty(FTrainerDataview.CELabel13,"Visible",false) end
    if inputPlaybackLines > 0 and FPVersion ~= 1 then
        setProperty(FTrainerDataview.CELabel14,"Caption","Initial RNG value: " .. dataFirstSeed)
        setProperty(FTrainerDataview.CELabel14,"Visible", true)
    else
        setProperty(FTrainerDataview.CELabel14,"Visible", false)
    end
end

objectDataviewMode = nil
function changeObjectDataviewIndex()
    if ReattachFP(0) == 0 then return end
    objectDataviewMode = getProperty(FTrainerObject.CEComboBox1,"ItemIndex")
end

--TODO: move all index checks from UpdateObjectDataview to here.
--updates object dataview offsets
function UpdateObjectDataviewOffset()
    if ReattachFP(0) == 0 then return end
    index =  getProperty(FTrainerObject.CEComboBox1,"ItemIndex")
    if index == 1 then
        for _,b in ipairs(hitBreakPoints) do
            debug_setBreakpoint(b[1])
        end
    else
        for _,b in ipairs(hitBreakPoints) do
            debug_removeBreakpoint(b[1])
        end
    end
    --disable editing if it's not on the right option.
    if index == 2 then
        setProperty(FTrainerObject.EditPointer1,"Enabled",true)
        setProperty(FTrainerObject.EditPointer2,"Enabled",true)
        return
    end
    --toggle all breakpoints on the list if the option is not last object hit

    setProperty(FTrainerObject.EditPointer1,"Enabled",false)
    setProperty(FTrainerObject.EditPointer2,"Enabled",false)
    --player object
    if index == 3 then
        setProperty(FTrainerObject.EditPointer1,"Text","1ba8")
        setProperty(FTrainerObject.EditPointer2,"Text",nil)
    end
    --camera object
    if index == 4 then
        setProperty(FTrainerObject.EditPointer1,"Text","2b48")
        setProperty(FTrainerObject.EditPointer2,"Text",nil)
    end
    -- updates object dataview immediately, to show the change.
    -- QUESTION: maybe not a good idea?
    UpdateObjectDataview()

end


-- updates object dataview values
lastObjectHit = nil
lastObject = nil
-- this array records which attribute values are going to be visible.
lastObjectAttr = {}
lastObjectAttrColor = {}
for i=1, 27 do lastObjectAttr[i] = false end
for i=1, 28 do lastObjectAttrColor[i] = false end
listSizeModifier = 15.3

--sets lastObjectHit
function checkHitBreakpoint(EIP,EAX,ECX,EDI)
    --reads reverse index to check what was the address that caused the function call.
    i = hitBreakPointsIndex[tostring(EIP)]
    local objectHit = lastObjectHit

    --reads affected register and updates last object hit pointer.
    if hitBreakPoints[i][2] == "eax" then
        lastObjectHit = EAX
    end
    if hitBreakPoints[i][2] == "ecx" then
        lastObjectHit = ECX
    end
    if hitBreakPoints[i][2] == "edi" then
        lastObjectHit = EDI
    end
    if hitBreakPoints[i][2] == "esi" then
        lastObjectHit = ESI
    end
    -- updates object dataview immediately, to show the change.
    if lastObjectHit ~= objectHit then
        for i=1, 27 do lastObjectAttr[i] = false end
        UpdateObjectDataview()
    end
    return
end

--Updates object dataview table
function UpdateObjectDataview()
    if ReattachFP(0) == 0 then return end
    index = getProperty(FTrainerObject.CEComboBox1,"ItemIndex")
    --updates pointers of globally stored objects.
    obj = nil
    if index == 0 then
        obj = lastObject
    end
    if index == 1 then
        obj = lastObjectHit
    else
        if index ~= 0 then
            -- TODO: refresh the object dataview here
            if isempty(getProperty(FTrainerObject.EditPointer2,"Text")) then
                obj = "[" .. varBase .. "]+" .. getProperty(FTrainerObject.EditPointer1,"Text")
            else
                obj = "[[" .. varBase .. "]+" .. getProperty(FTrainerObject.EditPointer1,"Text") .. "]+" .. getProperty(FTrainerObject.EditPointer2,"Text")
            end
            obj = readInteger(obj)
            if obj ~= lastObject then
                for i=1, 27 do lastObjectAttr[i] = false end
            end
        end
    end
    if isempty(obj) or isempty(readDouble(obj+0x14)) then
        setProperty(FTrainerObject.CELabel4,"Caption",nil)
    else
        setProperty(FTrainerObject.CELabel4,"Caption",string.format("Object: %x", obj))
    end
    lastObject = obj
    UpdateObjectDataview1(obj)
end

--fills up the listbox on the object dataview form with values found in the given array.
function UpdateObjectDataview1(obj)
    if isempty(obj) or isempty(readDouble(obj+0x14)) then
        -- when the pointer is invalid for some reason. you have to either make the table invisible or give the red color for the caption.
        setProperty(FTrainerObject.CEListBox1,"Enabled",false)
        return
    end

    --if the pointer is valid, go through all values and update them. a loop that starts on f0 and reads doubles up until 1b8 is enough. and then 1c0 is an int
    setProperty(FTrainerObject.CEListBox1,"Enabled",true)
    S = FTrainerObject.CEListBox1.getItems()
    --S = FTrainerObject.CEListBox2.getItems()
    S.beginUpdate()
    S.clear()

    -- read positions X and Y.
    -- always assume these are readable?
    addr = obj + 0xa0
    addr1 = obj + 0xa8
    val = readInteger(addr)
    val1 = readInteger(addr1)
    if val > 2^31 then
        val = val - 2^32
    end
    if val1 > 2^31 then
        val1 = val1 - 2^32
    end

    --quick check to see if the values are short ints
    if math.abs(val) > 2^16 or math.abs(val1) > 2^16 then
        setProperty(FTrainerObject.CEListBox1,"Enabled",false)
        return
    end

    str = "Pos. X : " .. string.format("%d",val) .. " : " .. string.format("%d",val1)
    S.add(str)
    addr = obj + 0xa4
    addr1 = obj + 0xac
    val = readInteger(addr)
    val1 = readInteger(addr1)
    if val > 2^31 then
        val = val - 2^32
    end
    if val1 > 2^31 then
        val1 = val1 - 2^32
    end
    str = "Pos. Y : " .. string.format("%d",val) .. " : " .. string.format("%d",val1)
    --S.setString(1,str)
    S.add(str)
    i = 3
    b = readInteger(obj+0x14) + 0xf0
    while i < 29 do
        str = tostring(i-2) .. " : "
        if i - 2 < 10 then
            str = "0" .. str
        end
        str = "Attr. " .. str
        val = readDouble(b)
        if (not isempty(val) and val ~= 0) or lastObjectAttr[i-2] then
            --TODO: here you have to update lastObjectAttr alongside the string.
            lastObjectAttr[i-2] = true
            str = str .. tostring(Round3(val))
            --S.setString(i-1,str)
            S.add(str)
        end
        b = b + 0x8
        i = i + 1
    end
    str = "Attr. 27 : "
    addr = readInteger(obj) + 0x1c0
    val = readInteger(addr)
    if not isempty(val) and val ~= 0 then
        str = str .. tostring(val)
        --S.setString(28,str)
        S.add(str)
    end
    --update the form's size and position of buttons alongside the listbox update.
    n = S.Count
    m = getProperty(FTrainerObject.CEListBox1, "Top") + (n * listSizeModifier)
    --adjust the bottom objects properties to the itembox's size
    setProperty(FTrainerObject.CEListBox1,"Height", n * listSizeModifier)
    setProperty(FTrainerObject.CEButton1, "Top", 22 + m)
    setProperty(FTrainerObject.CECheckbox1, "Top", 59 + m)
    setProperty(FTrainerObject,"Height", 82 + m)
    setProperty(FTrainerObject.CEListBox1,"Items",S)
    S.endUpdate()
end

--default formclose function from cheat engine
function FormClose()
    return caHide --Possible options: caHide, caFree, caMinimize, caNone
end

--RNG Calculator related functions
--TODO: rename all buttonclick functions to names that represent
--what they actually do
function CEButton16Click()
    FTrainerCalc.show()
    CurrentRNGValue()
end

-- RNG Calculator Next
function CEButton14Click()
    local x = tonumber(getProperty(FTrainerCalc.CEEdit1,"Text"))
    if isempty(x) then
        x = 0
        --return
    end

    local n = tonumber(getProperty(FTrainerCalc.CEEdit2,"Text"))
    if isempty(n) then
        n = 0
    end

    local count = math.floor(tonumber(getProperty(FTrainerCalc.CEEdit3,"Text")))
    if isempty(count) then count = 1 end

    local tempvalue = tonumber(getProperty(FTrainerCalc.CEEdit4,"Text"))
    if isempty(tempvalue) then tempvalue = -1 end

    --calculates next rng value a fixed amount of times
    --TODO: actual variable names for all this
    while count > 0  and x ~= tempvalue do
        x = x * 0x343fd + 0x269ec3
        x = x % (2^32)
        n = n+1
        count = count - 1
     end

     setProperty(FTrainerCalc.CEEdit1,"Text",math.floor(x))
     setProperty(FTrainerCalc.CEEdit2,"Text",n)
end

-- RNG Calculator Previous
function CEButton15Click()

    local x = tonumber(getProperty(FTrainerCalc.CEEdit1,"Text"))
    if isempty(x) then
        x = 0
    end
    local n = tonumber(getProperty(FTrainerCalc.CEEdit2,"Text"))
    if isempty(n) then
        n = 0
    end
    local count = math.floor(tonumber(getProperty(FTrainerCalc.CEEdit3,"Text")))
    if isempty(count) then count = 1 end

    local tempvalue = tonumber(getProperty(FTrainerCalc.CEEdit4,"Text"))
    if isempty(tempvalue) then tempvalue = -1 end

    --the calculation is ((x - 0x269ec3) * 0xb9b33155) mod 0x10000000
    while count > 0  and x ~= tempvalue do
        x = x - 0x269ec3

        local x2 = x % (0x10000)
        local x1 = (x - x2) / 0x10000

        x = (x2 * 0x3155 + 0xb9b30000 * x2 + 0x31550000 * x1) % (2^32)

        n = n-1
        count = count - 1
    end
    setProperty(FTrainerCalc.CEEdit1,"Text",math.floor(x))
    setProperty(FTrainerCalc.CEEdit2,"Text",n)
end

--Copies current game's rng value into the field
function CurrentRNGValue()
    if ReattachFP(0) == 0 then return end
    setProperty(FTrainerCalc.CEEdit1,"Text",readInteger(varBossSeed))
end

--RNG counter related variables
RNGCounterAddress = "fp.exe+14F63A8"
RNGCounterTable = {0x369B01,0x369D81,0x2BEF8A,0x2BF21A}
RNGBreakpointCounter = 0
RNGBreakpointIsActive = false
RNGCameraTick = false

--counts RNG updates
function updateRNGCounter(addr)
    if RNGBreakpointIsActive then
        if RNGCameraTick == false or (not has_value(RNGCounterTable,addr)) then
            RNGBreakpointCounter = RNGBreakpointCounter + 1
            setProperty(FTrainerCalc.CELabel6,"Caption",RNGBreakpointCounter)
        end
        return 1
    end
    --if rngbreakpointisactive is false
    setProperty(FTrainerMain.BreakpointTimer,"Enabled",true)
    return 0
end

--toggles RNG breakpoint in write mode, for tracking rng updates
function ActivateRNGCounter()
    RNGBreakpointIsActive = getProperty(FTrainerCalc.CECheckbox1,"Checked")

    if not RNGBreakpointIsActive then
        debug_removeBreakpoint(RNGCounterAddress)
        return
    end
    --rngbreakpointisactive is true: restarts counters
    debug_setBreakpoint(RNGCounterAddress,4,bptWrite)
    RNGBreakpointCounter = 0
    setProperty(FTrainerCalc.CELabel6,"Caption","No Count")
end

--toggles option that ignores player and camera object rng updates,
--as they happen every game
function ToggleRNGTickCounter()
    RNGCameraTick = getProperty(FTrainerCalc.CECheckbox2,"Checked")
end

-- misc options section
--TODO: proper description of what these variables actually do. here.
miscHealth = 14
miscMeter = 100
miscBike = 3
miscSpeed = 15
miscTimerLock = false
miscDefaultWarp = false
miscSuperdog = false
miscExplode = false
miscInstantDeath = false
miscLimitedLives = false
miscCameraLock = false
miscCrystalPos = false
miscCrystalPosX = 206
miscCrystalPosY = 19
miscInvincibility = false
miscKeycard = false

--Update Misc Refill and Misc Speed Boost
function ChangeMiscRefill()
    --health refill
    local refill = getProperty(FTrainerMain.MiscRefill1,"Text")
    if isempty(refill) then miscHealth = 14
    else
        refill = tonumber(refill)
        if isempty(refill) then miscHealth = 14
        else
            if refill < 0 or refill > 14 then miscHealth = 14
            else miscHealth = refill end
    end end

    --meter refill
    refill = getProperty(FTrainerMain.MiscRefill2,"Text")
    if isempty(refill) then miscMeter = 100
    else
        refill = tonumber(refill)
        if isempty(refill) then miscMeter = 100
        else
            if refill < 0 or refill > 100 then miscMeter = 100
            else miscMeter = refill end
    end end

    --bike heahth refill
    refill = getProperty(FTrainerMain.MiscRefill3,"Text")
    if isempty(refill) then miscBike = 3
    else
        refill = tonumber(refill)
        if isempty(refill) then miscBike = 3
        else
            if refill < 0 then miscBike = 3
            else miscBike = math.floor(refill) end
    end end

    --speed trigger
    refill = getProperty(FTrainerMain.MiscSpeed,"Text")
    if isempty(refill) then miscSpeed = 15
    else
        refill = tonumber(refill)
        if isempty(refill) then miscSpeed = 15
        else
            if refill < 0 or (not(miscSuperdog == false or miscMovement) and refill > 15) then miscSpeed = 15
            else miscSpeed = refill end
    end end
end

--toggles timer lock
function ChangeTimerLock()
    miscTimerLock = getProperty(FTrainerMain.CECheckbox8,"Checked")
end

--toggles permanent keycards
function ToggleKeycard()
    if ReattachFP(0) == 0 then
        setProperty(FTrainerMain.CECheckbox22,"Checked",false)
        return
    end
    miscKeycard = getProperty(FTrainerMain.CECheckbox22,"Checked")
end

--toggles crystal display position change
function ToggleCrystalPosition()
    miscCrystalPos = getProperty(FTrainerMain.CECheckbox19,"Checked")
    if not miscCrystalPos then
        writeInteger(varCrystalPosX,206)
        writeInteger(varCrystalPosY,19)
    end
end

--changes position of crystals (or custom value) display on screen
function ChangeCrystalPosition()
    --crystalposx
    local temp = getProperty(FTrainerMain.CEEdit1,"Text")
    if isempty(temp) then miscCrystalPosX = 206
    else
        temp = tonumber(temp)
        if isempty(temp) then miscCrystalPosX = 206
        else miscCrystalPosX = math.floor(temp)
    end end
    --crystalposy
    local temp = getProperty(FTrainerMain.CEEdit2,"Text")
    if isempty(temp) then miscCrystalPosY = 19
    else
        temp = tonumber(temp)
        if isempty(temp) then miscCrystalPosX = 19
        else miscCrystalPosY = math.floor(temp)
    end end
end

--
miscLivesDisplay = false
function ToggleLivesDisplay()
    if ReattachFP(0) == 0 or FPVersion ~= 3 then
        setProperty(FTrainerMain.CECheckbox20,"Checked",false)
        return
    end
    miscLivesDisplay = getProperty(FTrainerMain.CECheckbox20,"Checked")
    if not miscLivesDisplay then
        writeInteger(varLivesDisplay,19)
        writeInteger(varLivesDisplay2,12)
    end
end

--toggles superdog mode: fest
function ToggleSuperdog()
    if ReattachFP(0) == 0 then
        setProperty(FTrainerMain.CECheckbox10,"Checked",false)
        return
    end

    miscSuperdog = getProperty(FTrainerMain.CECheckbox10,"Checked")
    --if mod is toggled, inject code to cause the effects.
    --TODO: potentially change all code injection text to
    --separate files.
    if miscSuperdog then
        autoAssemble([[
        //23aa0a
        "FP.exe"+23659A: //speed cap to the right
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        "FP.exe"+23663A: //speed cap downwards
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        "FP.exe"+2365E9: //speed cap left
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        "FP.exe"+23ACB6: // air drag
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        alloc(newmem1,128) // speed panel to the right
        label(returnhere1)
        label(exit1)
        newmem1:
        jb FP.exe+ECC608
        ucomisd xmm0,[FP.exe+12C35E8] //15
        ja FP.exe+ECC608
        exit1:
        jmp returnhere1
        "FP.exe"+ECC55F:
        jmp newmem1
        nop
        returnhere1:
        alloc(newmem2,128) // speed panel to the left
        label(returnhere2)
        label(exit2)
        newmem2:
        jbe FP.exe+ECC6EB
        movsd xmm0,[FP.exe+12C4760] //-15
        comisd xmm0,[eax+000000F8]
        ja FP.exe+ECC6EB
        exit2:
        jmp returnhere2
        "FP.exe"+ECC63A:
        jmp newmem2
        nop
        returnhere2:
        "FP.exe"+23AF73:  //top boundary
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        ]])
    else
    --undoes code injection and resets speed trigger variable.
        autoAssemble([[
        "FP.exe"+23659A: //speed cap right
        movsd [eax+000000F8],xmm1
        "FP.exe"+23663A: //speed cap downwards
        movsd [eax+00000120],xmm1
        "FP.exe"+23ACB6: //air drag
        movsd [edx+000000F8],xmm0
        "FP.exe"+2365E9: //speed cap left
        movsd [eax+000000F8],xmm0
        dealloc(newmem1) // speed panel to the right
        "FP.exe"+ECC55F:
        jb FP.exe+ECC608
        dealloc(newmem2) // speed panel to the left
        "FP.exe"+ECC63A:
        //jbe FP.exe+101D75B
        jbe fp.exe+ECC6EB
        "FP.exe"+23AF73:  //top boundary
        movsd [eax+000001B0],xmm0
        ]])

        if miscSpeed > 15 then
            miscSpeed = 15
            setProperty(FTrainerMain.MiscSpeed,"Text","15")
        end
    end
    ChangeMiscRefill()
end

--ExplodeForNoReason
function TriggerExplode()
    writeDouble(varState,9)
    writeDouble(varExplode,1)
end

--Explodes randomly depending on RNG
function ToggleRandomExplode()
    if ReattachFP(0) == 0 then
        setProperty(FTrainerMain.CECheckbox9,"Checked",false)
        return
    end
    miscExplode = getProperty(FTrainerMain.CECheckbox9,"Checked")
end

--toggles Instant Death mod yay
function ToggleInstantDeath()
    if ReattachFP(0) == 0 then
        setProperty(FTrainerMain.CECheckbox11,"Checked",false)
        return
    end
    miscInstantDeath = getProperty(FTrainerMain.CECheckbox11,"Checked")
    if miscInstantDeath then
        --code injection to apply instant death mod
        autoAssemble([[
        alloc(newmem3,512) // shield damage
        label(returnhere3)
        label(exit3)
        newmem3:
        mov eax,[edi+00001BA8]
        mov eax,[eax+00000014]
        movsd xmm0,[FP.exe+12C1938] //9
        movsd [eax+00000150],xmm0
        mov eax,[edi+0000DC8]
        exit3:
        jmp returnhere3
        "FP.exe"+289A02:
        jmp newmem3
        nop
        returnhere3:
        "FP.exe"+289D9A: //damage
        jmp fp.exe+28A0C8
        nop
        "FP.exe"+2A86F9: //invincibility
        mov eax,[edi+00001BA8]
        movsd xmm0,[FP.exe+12C1938] //9
        mov eax,[eax+14]
        movsd [eax+150],xmm0
        "FP.exe"+2E5F0A: //damage 2
        jmp fp.exe+2E625B
        nop
        ]])
    else
        --code injection to undo instant death mod
        autoAssemble([[
        dealloc(newmem3) // shield damage
        "FP.exe"+289A02:
        mov eax,[edi+00000DC8]
        dealloc(newmem4)
        "FP.exe"+289D9A: //damage
        jbe fp.exe+28A0C8
        "FP.exe"+2A86F9: //invincibility
        mov eax,[edi+00000DC8]
        movsd xmm0,[FP.exe+12E48C8]
        mov eax,[eax+14]
        movsd [eax+110],xmm0
        "FP.exe"+2E5F0A: //damage 2
        jbe fp.exe+2E625B
        ]])
        --extra injection in case invincibility is still toggled
        if miscInvincibility then
            autoAssemble([[
            "fp.exe"+2A86FF:
            jmp fp.exe+2A8707
            ]])
        end
        writeInteger(varHealthBar,3)
    end
end

--Toggles limited lives mod
function ToggleLimitedLives()
    if ReattachFP(0) == 0 or FPVersion ~= 3 then
        setProperty(FTrainerMain.CECheckbox12,"Checked",false)
        return
    end
    miscLimitedLives = getProperty(FTrainerMain.CECheckbox12,"Checked")

    if miscLimitedLives then
    --code injection to activate actual gameover
    autoAssemble([[
        "FP.exe"+2C0429: //gameover
        mov [edi+10A00],00000003
        ]])
    else
    --code injection to remove actual gameover
    autoAssemble([[
        "FP.exe"+2C0429: //gameover
        mov [edi+10A00],0000004A
        ]])
    end
end

--Toggles Camera Lock mod
function ToggleCameraLock()
    if ReattachFP(0) == 0 then
        setProperty(FTrainerMain.CECheckbox13,"Checked",false)
        return
    end

    miscCameraLock = getProperty(FTrainerMain.CECheckbox13,"Checked")
    if miscCameraLock then
        --code injection to activate camera lock mod
        autoAssemble([[
        //camera for various screens 1
        "FP.exe"+3128C3:
        mov eax,[esi+00001BA8]
        "FP.exe"+3128D9:
        movsd xmm0,[eax+1a8]
        "FP.exe"+312901:
        mov eax,[esi+00001BA8]
        "FP.exe"+312915:
        movsd xmm0,[eax+1b0]
        //camera for various screens 2
        "FP.exe"+369FD6:
        mov eax,[esi+00001BA8]
        "FP.exe"+369FEC:
        movsd xmm0,[eax+1a8]
        "FP.exe"+36A014:
        mov eax,[esi+00001BA8]
        "FP.exe"+36A028:
        movsd xmm0,[eax+1b0]
        //camera for DV boss room
        "FP.exe"+2BF483:
        mov eax,[esi+00001BA8]
        "FP.exe"+2BF499:
        movsd xmm0,[eax+1a8]
        "FP.exe"+2BF4EE:
        mov eax,[esi+00001BA8]
        "FP.exe"+2BF502:
        movsd xmm0,[eax+1b0]
        //fixes camera for mantalith
        ]])
    else
    --code injection to deactivate camera lock mod
    autoAssemble([[
        //camera for various screens 1
        "FP.exe"+3128C3:
        mov eax,[esi+00002B48]
        "FP.exe"+3128D9:
        movsd xmm0,[eax+f0]
        "FP.exe"+312901:
        mov eax,[esi+00002B48]
        "FP.exe"+312915:
        movsd xmm0,[eax+f8]
        //camera for various screens 2
        "FP.exe"+369FD6:
        mov eax,[esi+00002B48]
        "FP.exe"+369FEC:
        addsd xmm0,[eax+f0]
        "FP.exe"+36A014:
        mov eax,[esi+00002B48]
        "FP.exe"+36A028:
        addsd xmm0,[eax+f8]
        //camera for DV boss room
        "FP.exe"+2BF483:
        mov eax,[esi+00002B48]
        "FP.exe"+2BF499:
        movsd xmm0,[eax+f0]
        "FP.exe"+2BF4EE:
        mov eax,[esi+00002B48]
        "FP.exe"+2BF502:
        movsd xmm0,[eax+f8]
        ]])
    end
end

miscSpeedScreen = false
miscSpeedScreenDisplay1 = 999
miscSpeedScreenDisplay2 = 3

--Changes crystals display to display variable chosen by the user.
function ShowSpeedOnScreen()
    if ReattachFP(0) == 0 then
        setProperty(FTrainerMain.CECheckbox13,"Checked",false)
        return
    end
    -- If health display is enabled, disable it before proceeding
    if miscHealthScreen then
        setProperty(FTrainerMain.CECheckbox17,"Checked",false)
        ShowHealthOnScreen()
    end
    local temp = miscSpeedScreen
    miscSpeedScreen = getProperty(FTrainerMain.CECheckbox14,"Checked")
    if miscSpeedScreen then
        --inject code for modifying display
        --that affects all options
        autoAssemble([[
        alloc(newmem6,512)
        registersymbol(newmem6)
        label(returnhere6)
        registersymbol(exit6)
        label(exit6)
        alloc(netspeed,32)
        registersymbol(netspeed)
        label(netspeed1)
        registersymbol(netspeed1)
        label(biggerspeed)
        registersymbol(biggerspeed)
        //label(biggerspeed1)
        //label(biggerspeed2)
        label(biggernetspeed)
        registersymbol(biggernetspeed)

        newmem6:
        mov eax,[esi+1ba8]
        test eax,eax
        je fp.exe+29EBB2
        mov eax,[eax+14]
        movsd xmm0,[eax+f8]
        mulsd xmm0,[FP.exe+12C0FA8] //=10
        //start truncation
        cvttsd2si eax,xmm0
        movd xmm0,eax
        cvtdq2pd xmm0,xmm0
        //end truncation
        comisd xmm0,[FP.exe+12D5730] //=0
        jnb exit6
        mulsd xmm0,[FP.exe+12BEB50] //=-1
        movsd [ecx+68],xmm0
        exit6:
        jmp fp.exe+29EBB2
        netspeed1: //using the netspeed memory instead of the actual value
        movsd xmm4,[eax+1a8]
        movsd xmm0,[netspeed]
        subsd xmm0,xmm4
        movsd [netspeed],xmm4
        ret

        biggerspeed:
        //you need to make sure both values are positive first
        movsd xmm4,[eax+f8]
        //ensures first value is positive
        comisd xmm4,[FP.exe+12D5730] //=0
        jnb biggerspeed1
        mulsd xmm4,[FP.exe+12BEB50] //=-1
        biggerspeed1:
        movsd xmm0,[eax+120]
        //ensures second value is positive
        comisd xmm0,[FP.exe+12D5730] //=0
        jnb biggerspeed2
        mulsd xmm0,[FP.exe+12BEB50] //=-1
        biggerspeed2:
        maxsd xmm0,xmm4
        ret

        biggernetspeed:

        ret
        netspeed: //use this to memorize position for difference/misc calc
        add [eax],al
        add [eax],al
        add [eax],al
        add [eax],al
        netspeedtoggle:
        add [eax],al
        add [eax],al
        "FP.exe"+29EBA5:
        jmp newmem6
        returnhere6:
        "FP.exe"+29EBB5:
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        //skips function that triggers 1-up
        "FP.exe"+29EBC7:
        jmp FP.exe+29EC05 //might be wrong
        nop
        nop
        nop
        nop
        ]])
        miscSpeedScreenDisplay1 = 999
        miscSpeedScreenDisplay2 = 3
        --fetches chosen option for which information to display
        temp = getProperty(FTrainerMain.CEComboBox4,"ItemIndex")
        --Index 0: displays horizontal speed as the attribute value.
        if temp == 0 then
            autoAssemble([[
            newmem6:
            mov eax,[esi+1ba8]
            test eax,eax
            je fp.exe+29EBB2
            mov eax,[eax+14]
            movsd xmm0,[eax+f8]
            mulsd xmm0,[FP.exe+12C0FA8] //=10
            ]])
            miscSpeedScreenDisplay1 = 999
            miscSpeedScreenDisplay2 = 3
        end
        if temp == 1 then
        --Index 1: displays vertical speed as the attribute value.
            autoAssemble([[
            newmem6:
            mov eax,[esi+1ba8]
            test eax,eax
            je fp.exe+29EBB2
            mov eax,[eax+14]
            movsd xmm0,[eax+120]
            mulsd xmm0,[FP.exe+12C0FA8] //=10
            ]])
            miscSpeedScreenDisplay1 = 999
            miscSpeedScreenDisplay2 = 3
        end
        --Index 2: displays horizontal or vertical speed,
        --depending on which one is bigger.
        if temp == 2 then
            autoAssemble([[
            newmem6:
            mov eax,[esi+1ba8]
            test eax,eax
            je fp.exe+29EBB2
            mov eax,[eax+14]
            call biggerspeed
            nop
            nop
            nop
            mulsd xmm0,[FP.exe+12C0FA8] //=10
            ]])
            miscSpeedScreenDisplay1 = 999
            miscSpeedScreenDisplay2 = 3

        end
        --Index 3: displays horizontal speed as displacement from last frame
        if temp == 3 then
            autoAssemble([[
            newmem6:
            mov eax,[esi+1ba8]
            test eax,eax
            je fp.exe+29EBB2
            mov eax,[eax+14]
            call netspeed1
            nop
            nop
            nop
            mulsd xmm0,[FP.exe+12C0FA8] //=10
            netspeed1:
            movsd xmm4,[eax+1a8]
            ]])
            miscSpeedScreenDisplay1 = 999
            miscSpeedScreenDisplay2 = 3
        end
        --Index 4: displays vertical speed as displacement from last frame
        if temp == 4 then
            autoAssemble([[
            newmem6:
            mov eax,[esi+1ba8]
            test eax,eax
            je fp.exe+29EBB2
            mov eax,[eax+14]
            call netspeed1
            nop
            nop
            nop
            mulsd xmm0,[FP.exe+12C0FA8] //=10
            netspeed1:
            movsd xmm4,[eax+1b0]
            ]])
            miscSpeedScreenDisplay1 = 999
            miscSpeedScreenDisplay2 = 3
        end
        --Index 5: displays horizontal position value
        if temp == 5 then
            autoAssemble([[
            newmem6:
            mov eax,[esi+1ba8]
            test eax,eax
            je fp.exe+29EBB2
            mov eax,[eax+14]
            movsd xmm0,[eax+1a8]
            addsd xmm0,[FP.exe+12D5730]
            ]])
            miscSpeedScreenDisplay1 = 99999
            miscSpeedScreenDisplay2 = 1
        end
        --Index 6: displays vertical position value
        if temp == 6 then
            autoAssemble([[
            newmem6:
            mov eax,[esi+1ba8]
            test eax,eax
            je fp.exe+29EBB2
            mov eax,[eax+14]
            movsd xmm0,[eax+1b0]
            addsd xmm0,[FP.exe+12D5730]
            ]])
            miscSpeedScreenDisplay1 = 99999
            miscSpeedScreenDisplay2 = 1
        end
        --Index 7: displays character's angle attribute
        if temp == 7 then
            autoAssemble([[
            newmem6:
            mov eax,[esi+1ba8]
            test eax,eax
            je fp.exe+29EBB2
            mov eax,[eax+14]
            movsd xmm0,[eax+158]
            addsd xmm0,[FP.exe+12D5730]
            ]])
            miscSpeedScreenDisplay1 = 999
            miscSpeedScreenDisplay2 = 3
        end
        --Index 8: displays shield health attribute
        if temp == 8 then
            autoAssemble([[
            newmem6:
            mov eax,[esi+dc8]
            test eax,eax
            je fp.exe+29EBB2
            mov eax,[eax+14]
            movsd xmm0,[eax+100]
            addsd xmm0,[FP.exe+12D5730]
            ]])
            miscSpeedScreenDisplay1 = 999
            miscSpeedScreenDisplay2 = 1
        end
        --Index 9: displays carol bike health attribute
        if temp == 9 then
            autoAssemble([[
            newmem6:
            mov eax,[esi+31c8]
            test eax,eax
            je fp.exe+29EBB2
            mov eax,[eax+14]
            movsd xmm0,[eax+100]
            addsd xmm0,[FP.exe+12D5730]
            ]])
            miscSpeedScreenDisplay1 = 999
            miscSpeedScreenDisplay2 = 1
        end
        --Index 10: displays invincibility frames attribute
        if temp == 10 then
            autoAssemble([[
            newmem6:
            mov eax,[esi+dc8]
            test eax,eax
            je fp.exe+29EBB2
            mov eax,[eax+14]
            movsd xmm0,[eax+110]
            addsd xmm0,[FP.exe+12D5730]
            ]])
            miscSpeedScreenDisplay1 = 9999
            miscSpeedScreenDisplay2 = 1
        end
        --Index 11: displays crystal count for improved movement mod
        if temp == 11 then
            autoAssemble([[
            newmem6:
            //mov eax,[eax+14]
            movsd xmm0,[FP.exe+1488F80] //this one is the orbs count
            mulsd xmm0,[FP.exe+12BEAD0] //=4
            addsd xmm0,[FP.exe+1488F58] //this one is the crystal count
            addsd xmm0,[FP.exe+12D5730]
            nop
            ]])
            miscSpeedScreenDisplay1 = 9999
            miscSpeedScreenDisplay2 = 1
        end
        --Index 13 (for testing): displays dreadbox heigth
        if temp == 13 then
            autoAssemble([[
            newmem6:
            mov eax,[fp.exe+14C01FC]
            mov eax,[eax+40]
            test eax,eax
            je fp.exe+29EBB2
            movd xmm0,[eax+08]
            cvtdq2pd xmm0,xmm0
            addsd xmm0,[FP.exe+12D5730]
            ]])
            miscSpeedScreenDisplay1 = 99999
            miscSpeedScreenDisplay2 = 1
        end
    --if screen display is being disable, undoes all code injection.
    else
        writeDouble(varCrystals,450)
        autoAssemble([[
        dealloc(newmem6)
        unregistersymbol(newmem6)
        unregistersymbol(netspeed0)
        unregistersymbol(netspeed1)
        dealloc(netspeed)
        unregistersymbol(netspeed)
        "FP.exe"+29EBA5:
        comisd xmm0,[ecx+68]
        "FP.exe"+29EBB5:
        movsd xmm0,[eax+00000090]
        "FP.exe"+29EBC7:
        mov eax,[esi+00002208]
        ]])
        miscSpeedScreenDisplay1 = 9999
        miscSpeedScreenDisplay2 = 1
    end
end

--Variable to keep track of HUD mod status. 
miscHud = false
-- TODO: more testing before making it available again
-- Toggles HUD on/off when called.
function MiscHUD()
    if ReattachFP(0) == 0 then
        setProperty(FTrainerMain.CECheckbox15,"Checked",false)
        return
    end
    miscHud = getProperty(FTrainerMain.CECheckbox15,"Checked")
    if not miscHud then
        writeBytes(varDrawing,{8})
    end
end

-- Variable to keep track of Improved Movement mod status.
--TODO: rename it for something better.
miscMovement = false
-- Toggles improved movement mod on/off when called.
function ToggleMiscMovement()
    if ReattachFP(0) == 0 then
        setProperty(FTrainerMain.CECheckbox16,"Checked",false)
        return
    end
    --Checks if mod is toggled on.
    miscMovement = getProperty(FTrainerMain.CECheckbox16,"Checked")
    --If mod is toggled on, changes most movement commands to scale with crystal count.
    if miscMovement then
    autoAssemble([[
        //lilac boosts right are increased according to multiplier
        alloc(movement1,128)
        label(exitmovement1)
        "fp.exe"+25D954:
        jmp movement1
        nop
        nop
        nop
        exitmovement1:
        movement1:
        movsd xmm2,[FP.exe+1488F80] //orbs
        mulsd xmm2,[fp.exe+12BEAD0] //=4
        addsd xmm2,[FP.exe+1488F58] //crystals
        mulsd xmm2,[FP.exe+12C1940] //=12
        divsd xmm2,[FP.exe+12C35D0] //=200
        addsd xmm2,[FP.exe+12C1940] //=12
        jmp exitmovement1

        //lilac boosts left are increased according to multiplier
        alloc(movement2,128)
        label(exitmovement2)
        "fp.exe"+25DA70:
        jmp movement2
        nop
        nop
        nop
        exitmovement2:
        movement2:
        movsd xmm1,[FP.exe+1488F80] //orbs
        mulsd xmm1,[fp.exe+12BEAD0] //=4
        addsd xmm1,[FP.exe+1488F58] //crystals
        mulsd xmm1,[FP.exe+12C1940] //=12
        divsd xmm1,[FP.exe+12C35D0] //=200
        addsd xmm1,[FP.exe+12C1940] //=12
        mulsd xmm1,[FP.exe+12BEB50] //=-1
        jmp exitmovement2

        //lilac dives right
        alloc(movement3,128)
        label(exitmovement3)
        "fp.exe"+25E792:
        jmp movement3
        nop
        nop
        nop
        exitmovement3:
        movement3:
        movsd xmm1,[FP.exe+1488F80] //orbs
        mulsd xmm1,[fp.exe+12BEAD0] //=4
        addsd xmm1,[FP.exe+1488F58] //crystals
        mulsd xmm1,[fp.exe+12BEAD8] //=5
        divsd xmm1,[FP.exe+12C35D0] //=200
        addsd xmm1,[fp.exe+12BEAD8] //=5
        jmp exitmovement3

        //lilac dives left
        alloc(movement4,128)
        label(exitmovement4)
        "fp.exe"+25E980:
        jmp movement4
        nop
        nop
        nop
        exitmovement4:
        movement4:
        movsd xmm1,[FP.exe+1488F80] //orbs
        mulsd xmm1,[fp.exe+12BEAD0] //=4
        addsd xmm1,[FP.exe+1488F58] //crystals
        mulsd xmm1,[fp.exe+12C3628] //=-5
        divsd xmm1,[FP.exe+12C35D0] //=200
        addsd xmm1,[fp.exe+12C3628] //=-5
        jmp exitmovement4

        //lilac cyclones
        alloc(movement5,128)
        label(exitmovement5)
        "fp.exe"+24B5B2:
        jmp movement5
        nop
        nop
        nop
        exitmovement5:
        movement5:
        movsd xmm0,[FP.exe+1488F80] //orbs
        mulsd xmm0,[fp.exe+12BEAD0] //=4
        addsd xmm0,[FP.exe+1488F58] //crystals
        mulsd xmm0,[fp.exe+12C1040] //=-3
        divsd xmm0,[FP.exe+12C35D0] //=200
        addsd xmm0,[fp.exe+12C1040] //=-3
        jmp exitmovement5

        //lilac boosts southeast
        alloc(movement6,128)
        label(exitmovement6)
        "fp.exe"+25DC8E:
        jmp movement6
        nop
        nop
        nop
        exitmovement6:
        movement6:
        movsd xmm2,[FP.exe+1488F80] //orbs
        mulsd xmm2,[fp.exe+12BEAD0] //=4
        addsd xmm2,[FP.exe+1488F58] //crystals
        mulsd xmm2,[fp.exe+12C0FF0] //=8
        divsd xmm2,[FP.exe+12C35D0] //=200
        addsd xmm2,[fp.exe+12C0FF0] //=8
        jmp exitmovement6

        //lilac boosts downwards diagonal
        alloc(movement7,128)
        label(exitmovement7)
        "fp.exe"+25DE9A:
        jmp movement7
        nop
        nop
        nop
        exitmovement7:
        movement7:
        movsd xmm1,xmm0
        movsd xmm0,[FP.exe+1488F80] //orbs
        mulsd xmm0,[fp.exe+12BEAD0] //=4
        addsd xmm0,[FP.exe+1488F58] //crystals
        mulsd xmm0,xmm1
        divsd xmm0,[FP.exe+12C35D0] //=200
        addsd xmm0,xmm1
        movsd [ecx+000000F8],xmm0
        jmp exitmovement7

        //lilac boosts diagonal (vertical)
        alloc(movement8,128)
        label(exitmovement8)
        "fp.exe"+25DBCD:
        jmp movement8
        nop
        nop
        nop
        exitmovement8:
        movement8:
        movsd xmm0,[FP.exe+1488F80] //orbs
        mulsd xmm0,[fp.exe+12BEAD0] //=4
        addsd xmm0,[FP.exe+1488F58] //crystals
        mulsd xmm0,[fp.exe+12C3C50] //=-8
        divsd xmm0,[FP.exe+12C35D0] //=200
        addsd xmm0,[fp.exe+12C3C50] //=-8
        jmp exitmovement8

        //lilac boosts upwards diagonal
        alloc(movement9,128)
        label(exitmovement9)
        "fp.exe"+25DB8D:
        jmp movement9
        nop
        nop
        nop
        exitmovement9:
        movement9:
        movsd xmm1,xmm0
        movsd xmm0,[FP.exe+1488F80] //orbs
        mulsd xmm0,[fp.exe+12BEAD0] //=4
        addsd xmm0,[FP.exe+1488F58] //crystals
        mulsd xmm0,xmm1
        divsd xmm0,[FP.exe+12C35D0] //=200
        addsd xmm0,xmm1
        movsd [eax+000000F8],xmm0
        xorps xmm1,xmm1
        jmp exitmovement9

        //milla flutter cap
        alloc(movement11,128)
        label(exitmovement11)
        "fp.exe"+2784C7:
        jmp movement11
        nop
        nop
        nop
        exitmovement11:
        movement11:
        movsd xmm1,[FP.exe+1488F80] //orbs
        mulsd xmm1,[fp.exe+12BEAD0] //=4
        addsd xmm1,[FP.exe+1488F58] //crystals
        mulsd xmm1,[fp.exe+12C35A8] //=-2
        divsd xmm1,[FP.exe+12C35D0] //=200
        addsd xmm1,[fp.exe+12C35A8] //=-2
        jmp exitmovement11

        //milla flutter modifier
        alloc(movement12,128)
        label(exitmovement12)
        "fp.exe"+2784E0:
        jmp movement12
        nop
        nop
        nop
        exitmovement12:
        movement12:
        movsd xmm2,[FP.exe+1488F80] //orbs
        mulsd xmm2,[fp.exe+12BEAD0] //=4
        addsd xmm2,[FP.exe+1488F58] //crystals
        mulsd xmm2,[fp.exe+12D5738] //=0.5
        divsd xmm2,[FP.exe+12C35D0] //=200
        addsd xmm2,[fp.exe+12D5738] //=0.5
        subsd xmm0,xmm2
        jmp exitmovement12

        //milla horizontal boost
        alloc(movement13,128)
        label(exitmovement13)
        "fp.exe"+27BF70:
        jmp movement13
        nop
        nop
        nop
        exitmovement13:
        movement13:
        movsd xmm2,[FP.exe+1488F80] //orbs
        mulsd xmm2,[fp.exe+12BEAD0] //=4
        addsd xmm2,[FP.exe+1488F58] //crystals
        mulsd xmm2,[fp.exe+12BEAE0] //=7
        divsd xmm2,[FP.exe+12C35D0] //=200
        addsd xmm2,[fp.exe+12BEAE0] //=7
        mulsd xmm1,xmm2
        jmp exitmovement13

        //milla vertical boost downwards
        alloc(movement14,128)
        label(exitmovement14)
        "fp.exe"+27BD29:
        jmp movement14
        nop
        nop
        nop
        exitmovement14:
        movement14:
        movsd xmm2,[FP.exe+1488F80] //orbs
        mulsd xmm2,[fp.exe+12BEAD0] //=4
        addsd xmm2,[FP.exe+1488F58] //crystals
        mulsd xmm2,[fp.exe+12BEAD8] //=5
        divsd xmm2,[FP.exe+12C35D0] //=200
        addsd xmm2,[fp.exe+12BEAD8] //=5
        subsd xmm1,xmm2
        jmp exitmovement14

        //milla vertical boost upwards
        alloc(movement15,128)
        label(exitmovement15)
        "fp.exe"+27BBC6:
        jmp movement15
        nop
        nop
        nop
        exitmovement15:
        movement15:
        movsd xmm0,[FP.exe+1488F80] //orbs
        mulsd xmm0,[fp.exe+12BEAD0] //=4
        addsd xmm0,[FP.exe+1488F58] //crystals
        mulsd xmm0,[fp.exe+12BEAD8] //=5
        divsd xmm0,[FP.exe+12C35D0] //=200
        addsd xmm0,[fp.exe+12BEAD8] //=5
        jmp exitmovement15

        //carol pounces right
        alloc(movement21,128)
        label(exitmovement21)
        "fp.exe"+249FE6:
        jmp movement21
        nop
        nop
        nop
        exitmovement21:
        movement21:
        movsd xmm2,[FP.exe+1488F80] //orbs
        mulsd xmm2,[fp.exe+12BEAD0] //=4
        addsd xmm2,[FP.exe+1488F58] //crystals
        mulsd xmm2,[fp.exe+12C0FE8] //=6
        divsd xmm2,[FP.exe+12C35D0] //=200
        addsd xmm2,[fp.exe+12C0FE8] //=6
        mulsd xmm1,xmm2
        jmp exitmovement21

        //carol pounces left
        alloc(movement22,128)
        label(exitmovement22)
        "fp.exe"+24A0E6:
        jmp movement22
        nop
        nop
        nop
        exitmovement22:
        movement22:
        movsd xmm2,[FP.exe+1488F80] //orbs
        mulsd xmm2,[fp.exe+12BEAD0] //=4
        addsd xmm2,[FP.exe+1488F58] //crystals
        mulsd xmm2,[fp.exe+12C0FE8] //=6
        divsd xmm2,[FP.exe+12C35D0] //=200
        addsd xmm2,[fp.exe+12C0FE8] //=6
        mulsd xmm1,xmm2
        jmp exitmovement22

        //ignores forced speed cap change from carol bike boosts
        "fp.exe"+23272F:
        jmp fp.exe+232737
        "fp.exe"+232495:
        jmp fp.exe+23249D

        //bike boosts right
        alloc(movement23,128)
        label(exitmovement23)
        "fp.exe"+268E50:
        jmp movement23
        nop
        nop
        nop
        exitmovement23:
        movement23:
        movsd xmm1,[FP.exe+1488F80] //orbs
        mulsd xmm1,[fp.exe+12BEAD0] //=4
        addsd xmm1,[FP.exe+1488F58] //crystals
        mulsd xmm1,[fp.exe+12C0FA8] //=10
        divsd xmm1,[FP.exe+12C35D0] //=200
        addsd xmm1,[fp.exe+12C0FA8] //=10
        jmp exitmovement23

        //bike boosts left
        alloc(movement24,128)
        label(exitmovement24)
        "fp.exe"+269920:
        jmp movement24
        nop
        nop
        nop
        exitmovement24:
        movement24:
        movsd xmm1,[FP.exe+1488F80] //orbs
        mulsd xmm1,[fp.exe+12BEAD0] //=4
        addsd xmm1,[FP.exe+1488F58] //crystals
        mulsd xmm1,[fp.exe+12C3530] //=-10
        divsd xmm1,[FP.exe+12C35D0] //=200
        addsd xmm1,[fp.exe+12C3530] //=-10
        jmp exitmovement24

        //carol double jump
        alloc(movement25,128)
        label(exitmovement25)
        "fp.exe"+26E639:
        jmp movement25
        nop
        nop
        nop
        exitmovement25:
        movement25:
        movsd xmm0,[FP.exe+1488F80] //orbs
        mulsd xmm0,[fp.exe+12BEAD0] //=4
        addsd xmm0,[FP.exe+1488F58] //crystals
        mulsd xmm0,[fp.exe+12C0FE8] //=6
        divsd xmm0,[FP.exe+12C35D0] //=200
        addsd xmm0,[fp.exe+12C0FE8] //=6
        jmp exitmovement25

        //carol double jump modifier
        alloc(movement26,128)
        label(exitmovement26)
        "fp.exe"+26E381:
        jmp movement26
        nop
        nop
        nop
        exitmovement26:
        movement26:
        movsd xmm0,[FP.exe+1488F80] //orbs
        mulsd xmm0,[fp.exe+12BEAD0] //=4
        addsd xmm0,[FP.exe+1488F58] //crystals
        mulsd xmm0,[fp.exe+12E4658] //=0.2
        divsd xmm0,[FP.exe+12C35D0] //=200
        addsd xmm0,[fp.exe+12E4658] //=0.2
        jmp exitmovement26
    ]])
    -- If deactivated, undoes all code injection done.
    else
        autoAssemble([[
            dealloc(movement1)
            "fp.exe"+25D954:
            mulsd xmm2,[FP.exe+12C1940]
            dealloc(movement2)
            "fp.exe"+25DA70:
            mulsd xmm1,[FP.exe+12C1940]
            dealloc(movement3)
            "fp.exe"+25E792:
            movsd xmm1,[fp.exe+12BEAD8]
            dealloc(movement4)
            "fp.exe"+25E980:
            movsd xmm1,[fp.exe+12C3628]
            dealloc(movement5)
            "fp.exe"+24B5B2:
            movsd xmm0,[fp.exe+12C1040]
            dealloc(movement6)
            "fp.exe"+25DC8E:
            movsd xmm2,[fp.exe+12C0FF0]
            dealloc(movement7)
            "fp.exe"+25DE9A:
            movsd [ecx+000000F8],xmm0
            dealloc(movement8)
            "fp.exe"+25DBCD:
            movsd xmm0,[fp.exe+12C3C50]
            dealloc(movement9)
            "fp.exe"+25DB8D:
            mov eax,[eax+00001BA8]
            dealloc(movement11)
            "fp.exe"+2784C7:
            movsd xmm1,[fp.exe+12C35A8]
            dealloc(movement12)
            "fp.exe"+2784E0:
            subsd xmm0,[fp.exe+12D5738]
            dealloc(movement13)
            "fp.exe"+27BF70:
            mulsd xmm1,[fp.exe+12BEAE0]
            dealloc(movement14)
            "fp.exe"+27BD29:
            subsd xmm1,[fp.exe+12BEAD8]
            dealloc(movement15)
            "fp.exe"+27BBC6:
            movsd xmm0,[fp.exe+12BEAD8]
            dealloc(movement21)
            "fp.exe"+249FE6:
            mulsd xmm1,[fp.exe+12C0FE8]
            dealloc(movement22)
            "fp.exe"+24A0E6:
            mulsd xmm1,[fp.exe+12C0FE8]
            "fp.exe"+23272F:
            movsd [eax+00000108],xmm1
            "fp.exe"+232495:
            movsd [eax+00000108],xmm1
            dealloc(movement23)
            "fp.exe"+268E50:
            movsd xmm1,[fp.exe+12C0FA8]
            dealloc(movement24)
            "fp.exe"+269920:
            movsd xmm1,[fp.exe+12C3530]
            dealloc(movement25)
            "fp.exe"+26E639:
            movsd xmm0,[fp.exe+12C0FE8]
            dealloc(movement26)
            "fp.exe"+26E381:
            movsd xmm0,[fp.exe+12E4658]
        ]])
        --Undoes values attributed to constants to their original values.
        local addr = readInteger(varAVs)
        if not isempty(addr) then

            local addr2 = addr + 0x100
            if readDouble(addr2) ~=0 then
                writeDouble(addr2,5)
            end
            addr2 = addr+0x108
            if readDouble(addr2) ~=0 then
                writeDouble(addr2,15)
            end
            addr2 = addr+0x110
            if readDouble(addr2) ~=0 then
                writeDouble(addr2,0.07375)
            end
            addr2 = addr+0x118
            if readDouble(addr2) ~=0 then
                writeDouble(addr2,0.203125)
            end
            addr2 = addr+0x128
            if readDouble(addr2) ~=0 then
                writeDouble(addr2,15)
            end
            addr2 = addr+0x130
            if readDouble(addr2) ~=0 then
                writeDouble(addr2,0.25)
            end
            addr2 = addr+0x138
            if readDouble(addr2) ~=0 then
                writeDouble(addr2,0.84)
            end
            if readDouble(varJump) ~=0 then
                writeDouble(varJump,(-7))
            end
        end
    end
end

--Variable to keep track of Enemy Health Display toggle 
miscHealthScreen = false
-- Toggles Health Display on screen on/off.
function ShowHealthOnScreen()
    if ReattachFP(0) == 0 then
        setProperty(FTrainerMain.CECheckbox16,"Checked",false)
        return
    end
    --If attribute display is toggled, deactivates it before proceeding.
    if miscSpeedScreen then
        setProperty(FTrainerMain.CECheckbox14,"Checked",false)
        ShowSpeedOnScreen()
    end
    -- If the health display has been toggled, add code injection.
    -- TODO: better commentary for the autoassemble
    miscHealthScreen = getProperty(FTrainerMain.CECheckbox17,"Checked")
    if miscHealthScreen then
        autoAssemble([[
        alloc(newmem9,2048)
        label(returnhere9)
        label(exit9)
        label(space0)
        label(code9)
        newmem9:
        jmp code9
        //space dedicated to pointer
        space1:
        add [eax],al
        add [eax],al
        code9:
        mov eax,[space1]
        test eax,eax
        je exit9
        movsd xmm0,[eax+f0]
        //start truncation
        cvttsd2si eax,xmm0
        movd xmm0,eax
        cvtdq2pd xmm0,xmm0
        exit9:
        movsd [ecx+68],xmm0
        jmp fp.exe+29EBB2
        jmp returnhere9
        space0: //start call
        mov ecx,[esp+04]
        mov [space1],ecx
        movsd [ecx+000000F0],xmm0
        mov [esp+04],ecx
        ret
        "FP.exe"+29EBA5:
        jmp newmem9
        returnhere9:
        "FP.exe"+29EBB5:
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        nop
        //skips function that triggers 1-up
        "FP.exe"+29EBC7:
        jmp FP.exe+29EC05
        nop
        nop
        nop
        nop
        //redirects hit address to a space0 call for every player hit trigger
        "FP.exe"+2B1219:
        push ecx
        call space0
        pop ecx
        nop
        "FP.exe"+2B015A:
        push ecx
        call space0
        pop ecx
        nop
        "FP.exe"+2AF84B:
        push ecx
        call space0
        pop ecx
        nop
        "FP.exe"+2B265E:
        push ecx
        call space0
        pop ecx
        nop
        "FP.exe"+2B227E:
        push ecx
        call space0
        pop ecx
        nop
        "FP.exe"+2B2A14:
        push eax
        call space0
        pop eax
        nop
        "FP.exe"+2AEE3D:
        push ecx
        call space0
        pop ecx
        nop
        "FP.exe"+2B06EA:
        push ecx
        call space0
        pop ecx
        nop
        "FP.exe"+2B0B48:
        push edi
        call space0
        pop edi
        nop
        "FP.exe"+2B0F8B:
        push eax
        call space0
        pop eax
        nop
        ]])
    -- If display is being disabled, undoes code injection.
    else
        writeDouble(varCrystals,450)
        autoAssemble([[
        dealloc(newmem9)
        "FP.exe"+29EBA5:
        comisd xmm0,[ecx+68]
        "FP.exe"+29EBB5:
        movsd xmm0,[eax+00000090]
        "FP.exe"+29EBC7:
        mov eax,[esi+00002208]
        "FP.exe"+2B1219:
        movsd [ecx+000000F0],xmm0
        "FP.exe"+2B015A:
        movsd [ecx+000000F0],xmm0
        "FP.exe"+2AF84B:
        movsd [ecx+000000F0],xmm0
        "FP.exe"+2B265E:
        movsd [ecx+000000F0],xmm0
        "FP.exe"+2B227E:
        movsd [ecx+000000F0],xmm0
        "FP.exe"+2B2A14:
        movsd [eax+000000F0],xmm0
        "FP.exe"+2AEE3D:
        movsd [ecx+000000F0],xmm0
        "FP.exe"+2B06EA:
        movsd [ecx+000000F0],xmm0
        "FP.exe"+2B0B48:
        movsd [edi+000000F0],xmm0
        "FP.exe"+2B0F8B:
        movsd [eax+000000F0],xmm0
        ]])
    end
end

--Toggles Invincibility mod on/off.
function ToggleInvincibility()
    if ReattachFP(0) == 0 then
        miscInvincibility = false
        setProperty(FTrainerMain.CECheckbox21,"Checked",false)
        return
    end
    miscInvincibility = getProperty(FTrainerMain.CECheckbox21,"Checked")
     -- if invincibility mod is being enabled, changes parts of invincibility 
    if miscInvincibility then
        autoAssemble([[
        "fp.exe"+25D60F: //lilac boost invincibility
        jmp fp.exe+25D617
        "fp.exe"+26C6BC: //carol kick invincibility
        jmp fp.exe+26C6C4
        ]])
        --if instant death mod is not enabled, do an extra change.
        if not miscInstantDeath then
            autoAssemble([[
            "fp.exe"+2A86FF:
            jmp fp.exe+2A8707
             ]])
        end
    else
    --if invincibility mod is being disabled, change code to their original maps.
        autoAssemble([[
        "fp.exe"+25D60F:
        movsd [ecx+00000110],xmm0
        "fp.exe"+26C6BC:
        movsd [ecx+00000110],xmm0
        ]])
    end
end

--Timer Stop related functions

miscTimerStop = false
miscTimerStopTrigger = false
miscTimerFrame = false
valTimerFrame = 20
miscTimerPosX = false
valTimerPosX = 0
miscTimerFlag = false
valTimerFlag = 2
miscTimerTriggerValue = 600000
miscTimerLimit = false
valTimerLimit = 600000
miscTimerLimitTrigger = false
miscTimerPB = false

--Opens Timer Stop settings window.
function OpenTimerWindow()
    FTrainerTimer.show()
end

--Activates timer stop according to first checkbox
function ActivateTimerStop()
    if ReattachFP(0) == 0 then return end
    miscTimerStop = getProperty(FTrainerTimer.CECheckbox1,"Checked")
    UpdateTimerStop()
end

--Updates timer stop according to checkbox states
function UpdateTimerStop()
    local temp = tonumber(getProperty(FTrainerTimer.CEEdit1,"Text"))
    if not isempty(temp) then
        valTimerFrame = temp
    end
    temp = tonumber(getProperty(FTrainerTimer.CEEdit2,"Text"))
    if not isempty(temp) then
        valTimerPosX = temp
    end
    temp = tonumber(getProperty(FTrainerTimer.CEEdit3,"Text"))
    if not isempty(temp) then
        valTimerFlag = temp
    end
    --Updates variables with checkbox status
    miscTimerStop = getProperty(FTrainerTimer.CECheckbox1,"Checked")
    miscTimerFrame = getProperty(FTrainerTimer.CECheckbox2,"Checked")
    miscTimerPosX = getProperty(FTrainerTimer.CECheckbox3,"Checked")
    miscTimerFlag = getProperty(FTrainerTimer.CECheckbox4,"Checked")
end

--Updates timer stop condition for screen ID
function UpdateCurrentTimerFrame()
    if ReattachFP(0) == 0 then return end

    local temp = readInteger(varFrame)
    if isempty(temp) then return end
    valTimerFrame = temp
    setProperty(FTrainerTimer.CECheckbox2,"Checked",true)
    setProperty(FTrainerTimer.CEEdit1,"Text",math.floor(temp))
    miscTimerFrame = true
end

--Updates timer stop condition for position.
function UpdateCurrentTimerPosX()
    if ReattachFP(0) == 0 then return end

    local temp = readDouble(varTrueX)
    if isempty(temp) then return end
    valTimerPosX = temp
    setProperty(FTrainerTimer.CECheckbox3,"Checked",true)
    setProperty(FTrainerTimer.CEEdit2,"Text",Round1(temp))
    miscTimerPosX = true
end

--Updates timer stop condition for checkpoint flag.
function UpdateCurrentTimerFlag()
    if ReattachFP(0) == 0 then return end

    local temp = readDouble(varCheckFlag)
    if isempty(temp) then return end
    valTimerFlag = temp
    setProperty(FTrainerTimer.CECheckbox4,"Checked",true)
    setProperty(FTrainerTimer.CEEdit3,"Text",math.floor(temp))
    miscTimerFlag = true
end

--Sets up new Timer Limit.
function UpdateTimerLimit()
    if ReattachFP(0) == 0 then return end

    miscTimerLimit = getProperty(FTrainerTimer.CECheckbox6,"Checked")
    miscTimerPB = getProperty(FTrainerTimer.CECheckbox7,"Checked")
    local text = getProperty(FTrainerTimer.CEEdit5,"Text")
    local t = {}
    --Parses 3 numbers from text box.
    for w in string.gmatch(text,"[%d]+") do
        t[#t+1] = w
    end
    if #t > 3 or isempty(tonumber(t[1])) then
        valTimerLimit = 600000
    else
        if isempty(tonumber(t[2])) then
            valTimerLimit = tonumber(t[1]) * 1000
        else
            if isempty(tonumber(t[3])) then
                valTimerLimit = tonumber(t[1]) * 1000 + tonumber(t[2]) * 10
            else valTimerLimit = tonumber(t[1]) * 60000 + tonumber(t[2]) * 1000 + tonumber(t[3]) * 10
            end
        end
    end
    --if the player writes a value assuming it's compared to the igt (value over 10 minutes), adjust to a value under 10 minutes
    if valTimerLimit > 600000 then valTimerLimit = valTimerLimit - 600000 end
end

--On script execution, attempts to immediately attach to the game
ReattachFP(1)
